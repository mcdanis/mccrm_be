
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Sub_Campaign
 * 
 */
export type Sub_Campaign = $Result.DefaultSelection<Prisma.$Sub_CampaignPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Contact_Parent
 * 
 */
export type Contact_Parent = $Result.DefaultSelection<Prisma.$Contact_ParentPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Contact_Note
 * 
 */
export type Contact_Note = $Result.DefaultSelection<Prisma.$Contact_NotePayload>
/**
 * Model Contact_Activity
 * 
 */
export type Contact_Activity = $Result.DefaultSelection<Prisma.$Contact_ActivityPayload>
/**
 * Model Contact_Bant
 * 
 */
export type Contact_Bant = $Result.DefaultSelection<Prisma.$Contact_BantPayload>
/**
 * Model Contact_Timeline
 * 
 */
export type Contact_Timeline = $Result.DefaultSelection<Prisma.$Contact_TimelinePayload>
/**
 * Model Campaign_User
 * 
 */
export type Campaign_User = $Result.DefaultSelection<Prisma.$Campaign_UserPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.sub_Campaign`: Exposes CRUD operations for the **Sub_Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sub_Campaigns
    * const sub_Campaigns = await prisma.sub_Campaign.findMany()
    * ```
    */
  get sub_Campaign(): Prisma.Sub_CampaignDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.contact_Parent`: Exposes CRUD operations for the **Contact_Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_Parents
    * const contact_Parents = await prisma.contact_Parent.findMany()
    * ```
    */
  get contact_Parent(): Prisma.Contact_ParentDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.contact_Note`: Exposes CRUD operations for the **Contact_Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_Notes
    * const contact_Notes = await prisma.contact_Note.findMany()
    * ```
    */
  get contact_Note(): Prisma.Contact_NoteDelegate<ExtArgs>;

  /**
   * `prisma.contact_Activity`: Exposes CRUD operations for the **Contact_Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_Activities
    * const contact_Activities = await prisma.contact_Activity.findMany()
    * ```
    */
  get contact_Activity(): Prisma.Contact_ActivityDelegate<ExtArgs>;

  /**
   * `prisma.contact_Bant`: Exposes CRUD operations for the **Contact_Bant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_Bants
    * const contact_Bants = await prisma.contact_Bant.findMany()
    * ```
    */
  get contact_Bant(): Prisma.Contact_BantDelegate<ExtArgs>;

  /**
   * `prisma.contact_Timeline`: Exposes CRUD operations for the **Contact_Timeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contact_Timelines
    * const contact_Timelines = await prisma.contact_Timeline.findMany()
    * ```
    */
  get contact_Timeline(): Prisma.Contact_TimelineDelegate<ExtArgs>;

  /**
   * `prisma.campaign_User`: Exposes CRUD operations for the **Campaign_User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaign_Users
    * const campaign_Users = await prisma.campaign_User.findMany()
    * ```
    */
  get campaign_User(): Prisma.Campaign_UserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Campaign: 'Campaign',
    Sub_Campaign: 'Sub_Campaign',
    Contact: 'Contact',
    Contact_Parent: 'Contact_Parent',
    Customer: 'Customer',
    Contact_Note: 'Contact_Note',
    Contact_Activity: 'Contact_Activity',
    Contact_Bant: 'Contact_Bant',
    Contact_Timeline: 'Contact_Timeline',
    Campaign_User: 'Campaign_User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "client" | "campaign" | "sub_Campaign" | "contact" | "contact_Parent" | "customer" | "contact_Note" | "contact_Activity" | "contact_Bant" | "contact_Timeline" | "campaign_User"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Sub_Campaign: {
        payload: Prisma.$Sub_CampaignPayload<ExtArgs>
        fields: Prisma.Sub_CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Sub_CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Sub_CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          findFirst: {
            args: Prisma.Sub_CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Sub_CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          findMany: {
            args: Prisma.Sub_CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>[]
          }
          create: {
            args: Prisma.Sub_CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          createMany: {
            args: Prisma.Sub_CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Sub_CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>[]
          }
          delete: {
            args: Prisma.Sub_CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          update: {
            args: Prisma.Sub_CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          deleteMany: {
            args: Prisma.Sub_CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Sub_CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Sub_CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Sub_CampaignPayload>
          }
          aggregate: {
            args: Prisma.Sub_CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSub_Campaign>
          }
          groupBy: {
            args: Prisma.Sub_CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sub_CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.Sub_CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<Sub_CampaignCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Contact_Parent: {
        payload: Prisma.$Contact_ParentPayload<ExtArgs>
        fields: Prisma.Contact_ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          findFirst: {
            args: Prisma.Contact_ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          findMany: {
            args: Prisma.Contact_ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>[]
          }
          create: {
            args: Prisma.Contact_ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          createMany: {
            args: Prisma.Contact_ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>[]
          }
          delete: {
            args: Prisma.Contact_ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          update: {
            args: Prisma.Contact_ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          deleteMany: {
            args: Prisma.Contact_ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Contact_ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ParentPayload>
          }
          aggregate: {
            args: Prisma.Contact_ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_Parent>
          }
          groupBy: {
            args: Prisma.Contact_ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_ParentCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_ParentCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Contact_Note: {
        payload: Prisma.$Contact_NotePayload<ExtArgs>
        fields: Prisma.Contact_NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          findFirst: {
            args: Prisma.Contact_NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          findMany: {
            args: Prisma.Contact_NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>[]
          }
          create: {
            args: Prisma.Contact_NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          createMany: {
            args: Prisma.Contact_NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>[]
          }
          delete: {
            args: Prisma.Contact_NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          update: {
            args: Prisma.Contact_NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          deleteMany: {
            args: Prisma.Contact_NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Contact_NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_NotePayload>
          }
          aggregate: {
            args: Prisma.Contact_NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_Note>
          }
          groupBy: {
            args: Prisma.Contact_NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_NoteCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_NoteCountAggregateOutputType> | number
          }
        }
      }
      Contact_Activity: {
        payload: Prisma.$Contact_ActivityPayload<ExtArgs>
        fields: Prisma.Contact_ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          findFirst: {
            args: Prisma.Contact_ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          findMany: {
            args: Prisma.Contact_ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>[]
          }
          create: {
            args: Prisma.Contact_ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          createMany: {
            args: Prisma.Contact_ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>[]
          }
          delete: {
            args: Prisma.Contact_ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          update: {
            args: Prisma.Contact_ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          deleteMany: {
            args: Prisma.Contact_ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Contact_ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_ActivityPayload>
          }
          aggregate: {
            args: Prisma.Contact_ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_Activity>
          }
          groupBy: {
            args: Prisma.Contact_ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_ActivityCountAggregateOutputType> | number
          }
        }
      }
      Contact_Bant: {
        payload: Prisma.$Contact_BantPayload<ExtArgs>
        fields: Prisma.Contact_BantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_BantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_BantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          findFirst: {
            args: Prisma.Contact_BantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_BantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          findMany: {
            args: Prisma.Contact_BantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>[]
          }
          create: {
            args: Prisma.Contact_BantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          createMany: {
            args: Prisma.Contact_BantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_BantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>[]
          }
          delete: {
            args: Prisma.Contact_BantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          update: {
            args: Prisma.Contact_BantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          deleteMany: {
            args: Prisma.Contact_BantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_BantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Contact_BantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_BantPayload>
          }
          aggregate: {
            args: Prisma.Contact_BantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_Bant>
          }
          groupBy: {
            args: Prisma.Contact_BantGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_BantGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_BantCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_BantCountAggregateOutputType> | number
          }
        }
      }
      Contact_Timeline: {
        payload: Prisma.$Contact_TimelinePayload<ExtArgs>
        fields: Prisma.Contact_TimelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Contact_TimelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Contact_TimelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          findFirst: {
            args: Prisma.Contact_TimelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Contact_TimelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          findMany: {
            args: Prisma.Contact_TimelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>[]
          }
          create: {
            args: Prisma.Contact_TimelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          createMany: {
            args: Prisma.Contact_TimelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Contact_TimelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>[]
          }
          delete: {
            args: Prisma.Contact_TimelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          update: {
            args: Prisma.Contact_TimelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          deleteMany: {
            args: Prisma.Contact_TimelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Contact_TimelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Contact_TimelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Contact_TimelinePayload>
          }
          aggregate: {
            args: Prisma.Contact_TimelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact_Timeline>
          }
          groupBy: {
            args: Prisma.Contact_TimelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Contact_TimelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.Contact_TimelineCountArgs<ExtArgs>
            result: $Utils.Optional<Contact_TimelineCountAggregateOutputType> | number
          }
        }
      }
      Campaign_User: {
        payload: Prisma.$Campaign_UserPayload<ExtArgs>
        fields: Prisma.Campaign_UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Campaign_UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Campaign_UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          findFirst: {
            args: Prisma.Campaign_UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Campaign_UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          findMany: {
            args: Prisma.Campaign_UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>[]
          }
          create: {
            args: Prisma.Campaign_UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          createMany: {
            args: Prisma.Campaign_UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Campaign_UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>[]
          }
          delete: {
            args: Prisma.Campaign_UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          update: {
            args: Prisma.Campaign_UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          deleteMany: {
            args: Prisma.Campaign_UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Campaign_UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Campaign_UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Campaign_UserPayload>
          }
          aggregate: {
            args: Prisma.Campaign_UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign_User>
          }
          groupBy: {
            args: Prisma.Campaign_UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<Campaign_UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.Campaign_UserCountArgs<ExtArgs>
            result: $Utils.Optional<Campaign_UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    client_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    client_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    title: string | null
    role: string | null
    password: string | null
    client_id: number | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    title: string | null
    role: string | null
    password: string | null
    client_id: number | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    title: number
    role: number
    password: number
    client_id: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    client_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    client_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    title?: true
    role?: true
    password?: true
    client_id?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    title?: true
    role?: true
    password?: true
    client_id?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    title?: true
    role?: true
    password?: true
    client_id?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    title: string
    role: string
    password: string
    client_id: number
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    role?: boolean
    password?: boolean
    client_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    role?: boolean
    password?: boolean
    client_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    title?: boolean
    role?: boolean
    password?: boolean
    client_id?: boolean
    createdAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      title: string
      role: string
      password: string
      client_id: number
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly title: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly client_id: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    address: string | null
    industry: string | null
    phone_number: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    address: string | null
    industry: string | null
    phone_number: string | null
    status: string | null
    createdAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    email: number
    address: number
    industry: number
    phone_number: number
    status: number
    createdAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    industry?: true
    phone_number?: true
    status?: true
    createdAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    industry?: true
    phone_number?: true
    status?: true
    createdAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    address?: true
    industry?: true
    phone_number?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    name: string
    email: string
    address: string
    industry: string
    phone_number: string
    status: string
    createdAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    industry?: boolean
    phone_number?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    industry?: boolean
    phone_number?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    address?: boolean
    industry?: boolean
    phone_number?: boolean
    status?: boolean
    createdAt?: boolean
  }


  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      address: string
      industry: string
      phone_number: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly name: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly industry: FieldRef<"Client", 'String'>
    readonly phone_number: FieldRef<"Client", 'String'>
    readonly status: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    id: number | null
    client_id: number | null
    created_by: number | null
  }

  export type CampaignSumAggregateOutputType = {
    id: number | null
    client_id: number | null
    created_by: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: number | null
    name: string | null
    client_id: number | null
    status: string | null
    created_by: number | null
    createdAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: number | null
    name: string | null
    client_id: number | null
    status: string | null
    created_by: number | null
    createdAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    client_id: number
    status: number
    created_by: number
    createdAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    id?: true
    client_id?: true
    created_by?: true
  }

  export type CampaignSumAggregateInputType = {
    id?: true
    client_id?: true
    created_by?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    client_id?: true
    status?: true
    created_by?: true
    createdAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    client_id?: true
    status?: true
    created_by?: true
    createdAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    client_id?: true
    status?: true
    created_by?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: number
    name: string
    client_id: number
    status: string
    created_by: number
    createdAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    client_id?: boolean
    status?: boolean
    created_by?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    client_id?: boolean
    status?: boolean
    created_by?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    client_id?: boolean
    status?: boolean
    created_by?: boolean
    createdAt?: boolean
  }


  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      client_id: number
      status: string
      created_by: number
      createdAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'Int'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly client_id: FieldRef<"Campaign", 'Int'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly created_by: FieldRef<"Campaign", 'Int'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
  }


  /**
   * Model Sub_Campaign
   */

  export type AggregateSub_Campaign = {
    _count: Sub_CampaignCountAggregateOutputType | null
    _avg: Sub_CampaignAvgAggregateOutputType | null
    _sum: Sub_CampaignSumAggregateOutputType | null
    _min: Sub_CampaignMinAggregateOutputType | null
    _max: Sub_CampaignMaxAggregateOutputType | null
  }

  export type Sub_CampaignAvgAggregateOutputType = {
    id: number | null
    campaign_id: number | null
    owner: number | null
    manager: number | null
    client_id: number | null
    created_by: number | null
  }

  export type Sub_CampaignSumAggregateOutputType = {
    id: number | null
    campaign_id: number | null
    owner: number | null
    manager: number | null
    client_id: number | null
    created_by: number | null
  }

  export type Sub_CampaignMinAggregateOutputType = {
    id: number | null
    campaign_id: number | null
    name: string | null
    owner: number | null
    manager: number | null
    status: string | null
    client_id: number | null
    created_by: number | null
    createdAt: Date | null
  }

  export type Sub_CampaignMaxAggregateOutputType = {
    id: number | null
    campaign_id: number | null
    name: string | null
    owner: number | null
    manager: number | null
    status: string | null
    client_id: number | null
    created_by: number | null
    createdAt: Date | null
  }

  export type Sub_CampaignCountAggregateOutputType = {
    id: number
    campaign_id: number
    name: number
    owner: number
    manager: number
    status: number
    client_id: number
    created_by: number
    createdAt: number
    _all: number
  }


  export type Sub_CampaignAvgAggregateInputType = {
    id?: true
    campaign_id?: true
    owner?: true
    manager?: true
    client_id?: true
    created_by?: true
  }

  export type Sub_CampaignSumAggregateInputType = {
    id?: true
    campaign_id?: true
    owner?: true
    manager?: true
    client_id?: true
    created_by?: true
  }

  export type Sub_CampaignMinAggregateInputType = {
    id?: true
    campaign_id?: true
    name?: true
    owner?: true
    manager?: true
    status?: true
    client_id?: true
    created_by?: true
    createdAt?: true
  }

  export type Sub_CampaignMaxAggregateInputType = {
    id?: true
    campaign_id?: true
    name?: true
    owner?: true
    manager?: true
    status?: true
    client_id?: true
    created_by?: true
    createdAt?: true
  }

  export type Sub_CampaignCountAggregateInputType = {
    id?: true
    campaign_id?: true
    name?: true
    owner?: true
    manager?: true
    status?: true
    client_id?: true
    created_by?: true
    createdAt?: true
    _all?: true
  }

  export type Sub_CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sub_Campaign to aggregate.
     */
    where?: Sub_CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sub_Campaigns to fetch.
     */
    orderBy?: Sub_CampaignOrderByWithRelationInput | Sub_CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Sub_CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sub_Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sub_Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sub_Campaigns
    **/
    _count?: true | Sub_CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sub_CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sub_CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sub_CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sub_CampaignMaxAggregateInputType
  }

  export type GetSub_CampaignAggregateType<T extends Sub_CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateSub_Campaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSub_Campaign[P]>
      : GetScalarType<T[P], AggregateSub_Campaign[P]>
  }




  export type Sub_CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Sub_CampaignWhereInput
    orderBy?: Sub_CampaignOrderByWithAggregationInput | Sub_CampaignOrderByWithAggregationInput[]
    by: Sub_CampaignScalarFieldEnum[] | Sub_CampaignScalarFieldEnum
    having?: Sub_CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sub_CampaignCountAggregateInputType | true
    _avg?: Sub_CampaignAvgAggregateInputType
    _sum?: Sub_CampaignSumAggregateInputType
    _min?: Sub_CampaignMinAggregateInputType
    _max?: Sub_CampaignMaxAggregateInputType
  }

  export type Sub_CampaignGroupByOutputType = {
    id: number
    campaign_id: number
    name: string
    owner: number
    manager: number
    status: string
    client_id: number
    created_by: number
    createdAt: Date
    _count: Sub_CampaignCountAggregateOutputType | null
    _avg: Sub_CampaignAvgAggregateOutputType | null
    _sum: Sub_CampaignSumAggregateOutputType | null
    _min: Sub_CampaignMinAggregateOutputType | null
    _max: Sub_CampaignMaxAggregateOutputType | null
  }

  type GetSub_CampaignGroupByPayload<T extends Sub_CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sub_CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sub_CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sub_CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], Sub_CampaignGroupByOutputType[P]>
        }
      >
    >


  export type Sub_CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_id?: boolean
    name?: boolean
    owner?: boolean
    manager?: boolean
    status?: boolean
    client_id?: boolean
    created_by?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sub_Campaign"]>

  export type Sub_CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_id?: boolean
    name?: boolean
    owner?: boolean
    manager?: boolean
    status?: boolean
    client_id?: boolean
    created_by?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sub_Campaign"]>

  export type Sub_CampaignSelectScalar = {
    id?: boolean
    campaign_id?: boolean
    name?: boolean
    owner?: boolean
    manager?: boolean
    status?: boolean
    client_id?: boolean
    created_by?: boolean
    createdAt?: boolean
  }


  export type $Sub_CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sub_Campaign"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      campaign_id: number
      name: string
      owner: number
      manager: number
      status: string
      client_id: number
      created_by: number
      createdAt: Date
    }, ExtArgs["result"]["sub_Campaign"]>
    composites: {}
  }

  type Sub_CampaignGetPayload<S extends boolean | null | undefined | Sub_CampaignDefaultArgs> = $Result.GetResult<Prisma.$Sub_CampaignPayload, S>

  type Sub_CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Sub_CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sub_CampaignCountAggregateInputType | true
    }

  export interface Sub_CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sub_Campaign'], meta: { name: 'Sub_Campaign' } }
    /**
     * Find zero or one Sub_Campaign that matches the filter.
     * @param {Sub_CampaignFindUniqueArgs} args - Arguments to find a Sub_Campaign
     * @example
     * // Get one Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Sub_CampaignFindUniqueArgs>(args: SelectSubset<T, Sub_CampaignFindUniqueArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sub_Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Sub_CampaignFindUniqueOrThrowArgs} args - Arguments to find a Sub_Campaign
     * @example
     * // Get one Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Sub_CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, Sub_CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sub_Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignFindFirstArgs} args - Arguments to find a Sub_Campaign
     * @example
     * // Get one Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Sub_CampaignFindFirstArgs>(args?: SelectSubset<T, Sub_CampaignFindFirstArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sub_Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignFindFirstOrThrowArgs} args - Arguments to find a Sub_Campaign
     * @example
     * // Get one Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Sub_CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, Sub_CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sub_Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sub_Campaigns
     * const sub_Campaigns = await prisma.sub_Campaign.findMany()
     * 
     * // Get first 10 Sub_Campaigns
     * const sub_Campaigns = await prisma.sub_Campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sub_CampaignWithIdOnly = await prisma.sub_Campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Sub_CampaignFindManyArgs>(args?: SelectSubset<T, Sub_CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sub_Campaign.
     * @param {Sub_CampaignCreateArgs} args - Arguments to create a Sub_Campaign.
     * @example
     * // Create one Sub_Campaign
     * const Sub_Campaign = await prisma.sub_Campaign.create({
     *   data: {
     *     // ... data to create a Sub_Campaign
     *   }
     * })
     * 
     */
    create<T extends Sub_CampaignCreateArgs>(args: SelectSubset<T, Sub_CampaignCreateArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sub_Campaigns.
     * @param {Sub_CampaignCreateManyArgs} args - Arguments to create many Sub_Campaigns.
     * @example
     * // Create many Sub_Campaigns
     * const sub_Campaign = await prisma.sub_Campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Sub_CampaignCreateManyArgs>(args?: SelectSubset<T, Sub_CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sub_Campaigns and returns the data saved in the database.
     * @param {Sub_CampaignCreateManyAndReturnArgs} args - Arguments to create many Sub_Campaigns.
     * @example
     * // Create many Sub_Campaigns
     * const sub_Campaign = await prisma.sub_Campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sub_Campaigns and only return the `id`
     * const sub_CampaignWithIdOnly = await prisma.sub_Campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Sub_CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, Sub_CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sub_Campaign.
     * @param {Sub_CampaignDeleteArgs} args - Arguments to delete one Sub_Campaign.
     * @example
     * // Delete one Sub_Campaign
     * const Sub_Campaign = await prisma.sub_Campaign.delete({
     *   where: {
     *     // ... filter to delete one Sub_Campaign
     *   }
     * })
     * 
     */
    delete<T extends Sub_CampaignDeleteArgs>(args: SelectSubset<T, Sub_CampaignDeleteArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sub_Campaign.
     * @param {Sub_CampaignUpdateArgs} args - Arguments to update one Sub_Campaign.
     * @example
     * // Update one Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Sub_CampaignUpdateArgs>(args: SelectSubset<T, Sub_CampaignUpdateArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sub_Campaigns.
     * @param {Sub_CampaignDeleteManyArgs} args - Arguments to filter Sub_Campaigns to delete.
     * @example
     * // Delete a few Sub_Campaigns
     * const { count } = await prisma.sub_Campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Sub_CampaignDeleteManyArgs>(args?: SelectSubset<T, Sub_CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sub_Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sub_Campaigns
     * const sub_Campaign = await prisma.sub_Campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Sub_CampaignUpdateManyArgs>(args: SelectSubset<T, Sub_CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sub_Campaign.
     * @param {Sub_CampaignUpsertArgs} args - Arguments to update or create a Sub_Campaign.
     * @example
     * // Update or create a Sub_Campaign
     * const sub_Campaign = await prisma.sub_Campaign.upsert({
     *   create: {
     *     // ... data to create a Sub_Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sub_Campaign we want to update
     *   }
     * })
     */
    upsert<T extends Sub_CampaignUpsertArgs>(args: SelectSubset<T, Sub_CampaignUpsertArgs<ExtArgs>>): Prisma__Sub_CampaignClient<$Result.GetResult<Prisma.$Sub_CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sub_Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignCountArgs} args - Arguments to filter Sub_Campaigns to count.
     * @example
     * // Count the number of Sub_Campaigns
     * const count = await prisma.sub_Campaign.count({
     *   where: {
     *     // ... the filter for the Sub_Campaigns we want to count
     *   }
     * })
    **/
    count<T extends Sub_CampaignCountArgs>(
      args?: Subset<T, Sub_CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sub_CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sub_Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sub_CampaignAggregateArgs>(args: Subset<T, Sub_CampaignAggregateArgs>): Prisma.PrismaPromise<GetSub_CampaignAggregateType<T>>

    /**
     * Group by Sub_Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sub_CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sub_CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sub_CampaignGroupByArgs['orderBy'] }
        : { orderBy?: Sub_CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sub_CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSub_CampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sub_Campaign model
   */
  readonly fields: Sub_CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sub_Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Sub_CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sub_Campaign model
   */ 
  interface Sub_CampaignFieldRefs {
    readonly id: FieldRef<"Sub_Campaign", 'Int'>
    readonly campaign_id: FieldRef<"Sub_Campaign", 'Int'>
    readonly name: FieldRef<"Sub_Campaign", 'String'>
    readonly owner: FieldRef<"Sub_Campaign", 'Int'>
    readonly manager: FieldRef<"Sub_Campaign", 'Int'>
    readonly status: FieldRef<"Sub_Campaign", 'String'>
    readonly client_id: FieldRef<"Sub_Campaign", 'Int'>
    readonly created_by: FieldRef<"Sub_Campaign", 'Int'>
    readonly createdAt: FieldRef<"Sub_Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sub_Campaign findUnique
   */
  export type Sub_CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Sub_Campaign to fetch.
     */
    where: Sub_CampaignWhereUniqueInput
  }

  /**
   * Sub_Campaign findUniqueOrThrow
   */
  export type Sub_CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Sub_Campaign to fetch.
     */
    where: Sub_CampaignWhereUniqueInput
  }

  /**
   * Sub_Campaign findFirst
   */
  export type Sub_CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Sub_Campaign to fetch.
     */
    where?: Sub_CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sub_Campaigns to fetch.
     */
    orderBy?: Sub_CampaignOrderByWithRelationInput | Sub_CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sub_Campaigns.
     */
    cursor?: Sub_CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sub_Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sub_Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sub_Campaigns.
     */
    distinct?: Sub_CampaignScalarFieldEnum | Sub_CampaignScalarFieldEnum[]
  }

  /**
   * Sub_Campaign findFirstOrThrow
   */
  export type Sub_CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Sub_Campaign to fetch.
     */
    where?: Sub_CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sub_Campaigns to fetch.
     */
    orderBy?: Sub_CampaignOrderByWithRelationInput | Sub_CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sub_Campaigns.
     */
    cursor?: Sub_CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sub_Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sub_Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sub_Campaigns.
     */
    distinct?: Sub_CampaignScalarFieldEnum | Sub_CampaignScalarFieldEnum[]
  }

  /**
   * Sub_Campaign findMany
   */
  export type Sub_CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter, which Sub_Campaigns to fetch.
     */
    where?: Sub_CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sub_Campaigns to fetch.
     */
    orderBy?: Sub_CampaignOrderByWithRelationInput | Sub_CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sub_Campaigns.
     */
    cursor?: Sub_CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sub_Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sub_Campaigns.
     */
    skip?: number
    distinct?: Sub_CampaignScalarFieldEnum | Sub_CampaignScalarFieldEnum[]
  }

  /**
   * Sub_Campaign create
   */
  export type Sub_CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * The data needed to create a Sub_Campaign.
     */
    data: XOR<Sub_CampaignCreateInput, Sub_CampaignUncheckedCreateInput>
  }

  /**
   * Sub_Campaign createMany
   */
  export type Sub_CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sub_Campaigns.
     */
    data: Sub_CampaignCreateManyInput | Sub_CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sub_Campaign createManyAndReturn
   */
  export type Sub_CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sub_Campaigns.
     */
    data: Sub_CampaignCreateManyInput | Sub_CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sub_Campaign update
   */
  export type Sub_CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * The data needed to update a Sub_Campaign.
     */
    data: XOR<Sub_CampaignUpdateInput, Sub_CampaignUncheckedUpdateInput>
    /**
     * Choose, which Sub_Campaign to update.
     */
    where: Sub_CampaignWhereUniqueInput
  }

  /**
   * Sub_Campaign updateMany
   */
  export type Sub_CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sub_Campaigns.
     */
    data: XOR<Sub_CampaignUpdateManyMutationInput, Sub_CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Sub_Campaigns to update
     */
    where?: Sub_CampaignWhereInput
  }

  /**
   * Sub_Campaign upsert
   */
  export type Sub_CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * The filter to search for the Sub_Campaign to update in case it exists.
     */
    where: Sub_CampaignWhereUniqueInput
    /**
     * In case the Sub_Campaign found by the `where` argument doesn't exist, create a new Sub_Campaign with this data.
     */
    create: XOR<Sub_CampaignCreateInput, Sub_CampaignUncheckedCreateInput>
    /**
     * In case the Sub_Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Sub_CampaignUpdateInput, Sub_CampaignUncheckedUpdateInput>
  }

  /**
   * Sub_Campaign delete
   */
  export type Sub_CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
    /**
     * Filter which Sub_Campaign to delete.
     */
    where: Sub_CampaignWhereUniqueInput
  }

  /**
   * Sub_Campaign deleteMany
   */
  export type Sub_CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sub_Campaigns to delete
     */
    where?: Sub_CampaignWhereInput
  }

  /**
   * Sub_Campaign without action
   */
  export type Sub_CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sub_Campaign
     */
    select?: Sub_CampaignSelect<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    country: string | null
    address: string | null
    tag: string | null
    level_priority: string | null
    source: string | null
    status: string | null
    result_negotiation: string | null
    createdAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    country: string | null
    address: string | null
    tag: string | null
    level_priority: string | null
    source: string | null
    status: string | null
    result_negotiation: string | null
    createdAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    sub_campaign_id: number
    first_name: number
    last_name: number
    email: number
    country: number
    address: number
    tag: number
    level_priority: number
    source: number
    status: number
    result_negotiation: number
    createdAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    sub_campaign_id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    sub_campaign_id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    first_name?: true
    last_name?: true
    email?: true
    country?: true
    address?: true
    tag?: true
    level_priority?: true
    source?: true
    status?: true
    result_negotiation?: true
    createdAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    first_name?: true
    last_name?: true
    email?: true
    country?: true
    address?: true
    tag?: true
    level_priority?: true
    source?: true
    status?: true
    result_negotiation?: true
    createdAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    first_name?: true
    last_name?: true
    email?: true
    country?: true
    address?: true
    tag?: true
    level_priority?: true
    source?: true
    status?: true
    result_negotiation?: true
    createdAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    sub_campaign_id: number
    first_name: string
    last_name: string
    email: string
    country: string
    address: string
    tag: string
    level_priority: string
    source: string
    status: string
    result_negotiation: string
    createdAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_campaign_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    country?: boolean
    address?: boolean
    tag?: boolean
    level_priority?: boolean
    source?: boolean
    status?: boolean
    result_negotiation?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_campaign_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    country?: boolean
    address?: boolean
    tag?: boolean
    level_priority?: boolean
    source?: boolean
    status?: boolean
    result_negotiation?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    sub_campaign_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    country?: boolean
    address?: boolean
    tag?: boolean
    level_priority?: boolean
    source?: boolean
    status?: boolean
    result_negotiation?: boolean
    createdAt?: boolean
  }


  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sub_campaign_id: number
      first_name: string
      last_name: string
      email: string
      country: string
      address: string
      tag: string
      level_priority: string
      source: string
      status: string
      result_negotiation: string
      createdAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly sub_campaign_id: FieldRef<"Contact", 'Int'>
    readonly first_name: FieldRef<"Contact", 'String'>
    readonly last_name: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly country: FieldRef<"Contact", 'String'>
    readonly address: FieldRef<"Contact", 'String'>
    readonly tag: FieldRef<"Contact", 'String'>
    readonly level_priority: FieldRef<"Contact", 'String'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly status: FieldRef<"Contact", 'String'>
    readonly result_negotiation: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
  }


  /**
   * Model Contact_Parent
   */

  export type AggregateContact_Parent = {
    _count: Contact_ParentCountAggregateOutputType | null
    _avg: Contact_ParentAvgAggregateOutputType | null
    _sum: Contact_ParentSumAggregateOutputType | null
    _min: Contact_ParentMinAggregateOutputType | null
    _max: Contact_ParentMaxAggregateOutputType | null
  }

  export type Contact_ParentAvgAggregateOutputType = {
    id: number | null
    parent_contact_id: number | null
    contact_id: number | null
  }

  export type Contact_ParentSumAggregateOutputType = {
    id: number | null
    parent_contact_id: number | null
    contact_id: number | null
  }

  export type Contact_ParentMinAggregateOutputType = {
    id: number | null
    parent_contact_id: number | null
    contact_id: number | null
    createdAt: Date | null
  }

  export type Contact_ParentMaxAggregateOutputType = {
    id: number | null
    parent_contact_id: number | null
    contact_id: number | null
    createdAt: Date | null
  }

  export type Contact_ParentCountAggregateOutputType = {
    id: number
    parent_contact_id: number
    contact_id: number
    createdAt: number
    _all: number
  }


  export type Contact_ParentAvgAggregateInputType = {
    id?: true
    parent_contact_id?: true
    contact_id?: true
  }

  export type Contact_ParentSumAggregateInputType = {
    id?: true
    parent_contact_id?: true
    contact_id?: true
  }

  export type Contact_ParentMinAggregateInputType = {
    id?: true
    parent_contact_id?: true
    contact_id?: true
    createdAt?: true
  }

  export type Contact_ParentMaxAggregateInputType = {
    id?: true
    parent_contact_id?: true
    contact_id?: true
    createdAt?: true
  }

  export type Contact_ParentCountAggregateInputType = {
    id?: true
    parent_contact_id?: true
    contact_id?: true
    createdAt?: true
    _all?: true
  }

  export type Contact_ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Parent to aggregate.
     */
    where?: Contact_ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Parents to fetch.
     */
    orderBy?: Contact_ParentOrderByWithRelationInput | Contact_ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_Parents
    **/
    _count?: true | Contact_ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_ParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_ParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_ParentMaxAggregateInputType
  }

  export type GetContact_ParentAggregateType<T extends Contact_ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_Parent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_Parent[P]>
      : GetScalarType<T[P], AggregateContact_Parent[P]>
  }




  export type Contact_ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_ParentWhereInput
    orderBy?: Contact_ParentOrderByWithAggregationInput | Contact_ParentOrderByWithAggregationInput[]
    by: Contact_ParentScalarFieldEnum[] | Contact_ParentScalarFieldEnum
    having?: Contact_ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_ParentCountAggregateInputType | true
    _avg?: Contact_ParentAvgAggregateInputType
    _sum?: Contact_ParentSumAggregateInputType
    _min?: Contact_ParentMinAggregateInputType
    _max?: Contact_ParentMaxAggregateInputType
  }

  export type Contact_ParentGroupByOutputType = {
    id: number
    parent_contact_id: number
    contact_id: number
    createdAt: Date
    _count: Contact_ParentCountAggregateOutputType | null
    _avg: Contact_ParentAvgAggregateOutputType | null
    _sum: Contact_ParentSumAggregateOutputType | null
    _min: Contact_ParentMinAggregateOutputType | null
    _max: Contact_ParentMaxAggregateOutputType | null
  }

  type GetContact_ParentGroupByPayload<T extends Contact_ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_ParentGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_ParentGroupByOutputType[P]>
        }
      >
    >


  export type Contact_ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_contact_id?: boolean
    contact_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Parent"]>

  export type Contact_ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_contact_id?: boolean
    contact_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Parent"]>

  export type Contact_ParentSelectScalar = {
    id?: boolean
    parent_contact_id?: boolean
    contact_id?: boolean
    createdAt?: boolean
  }


  export type $Contact_ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_Parent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      parent_contact_id: number
      contact_id: number
      createdAt: Date
    }, ExtArgs["result"]["contact_Parent"]>
    composites: {}
  }

  type Contact_ParentGetPayload<S extends boolean | null | undefined | Contact_ParentDefaultArgs> = $Result.GetResult<Prisma.$Contact_ParentPayload, S>

  type Contact_ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Contact_ParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_ParentCountAggregateInputType | true
    }

  export interface Contact_ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_Parent'], meta: { name: 'Contact_Parent' } }
    /**
     * Find zero or one Contact_Parent that matches the filter.
     * @param {Contact_ParentFindUniqueArgs} args - Arguments to find a Contact_Parent
     * @example
     * // Get one Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_ParentFindUniqueArgs>(args: SelectSubset<T, Contact_ParentFindUniqueArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_Parent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Contact_ParentFindUniqueOrThrowArgs} args - Arguments to find a Contact_Parent
     * @example
     * // Get one Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentFindFirstArgs} args - Arguments to find a Contact_Parent
     * @example
     * // Get one Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_ParentFindFirstArgs>(args?: SelectSubset<T, Contact_ParentFindFirstArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentFindFirstOrThrowArgs} args - Arguments to find a Contact_Parent
     * @example
     * // Get one Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_Parents
     * const contact_Parents = await prisma.contact_Parent.findMany()
     * 
     * // Get first 10 Contact_Parents
     * const contact_Parents = await prisma.contact_Parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_ParentWithIdOnly = await prisma.contact_Parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_ParentFindManyArgs>(args?: SelectSubset<T, Contact_ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_Parent.
     * @param {Contact_ParentCreateArgs} args - Arguments to create a Contact_Parent.
     * @example
     * // Create one Contact_Parent
     * const Contact_Parent = await prisma.contact_Parent.create({
     *   data: {
     *     // ... data to create a Contact_Parent
     *   }
     * })
     * 
     */
    create<T extends Contact_ParentCreateArgs>(args: SelectSubset<T, Contact_ParentCreateArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_Parents.
     * @param {Contact_ParentCreateManyArgs} args - Arguments to create many Contact_Parents.
     * @example
     * // Create many Contact_Parents
     * const contact_Parent = await prisma.contact_Parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_ParentCreateManyArgs>(args?: SelectSubset<T, Contact_ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_Parents and returns the data saved in the database.
     * @param {Contact_ParentCreateManyAndReturnArgs} args - Arguments to create many Contact_Parents.
     * @example
     * // Create many Contact_Parents
     * const contact_Parent = await prisma.contact_Parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_Parents and only return the `id`
     * const contact_ParentWithIdOnly = await prisma.contact_Parent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_Parent.
     * @param {Contact_ParentDeleteArgs} args - Arguments to delete one Contact_Parent.
     * @example
     * // Delete one Contact_Parent
     * const Contact_Parent = await prisma.contact_Parent.delete({
     *   where: {
     *     // ... filter to delete one Contact_Parent
     *   }
     * })
     * 
     */
    delete<T extends Contact_ParentDeleteArgs>(args: SelectSubset<T, Contact_ParentDeleteArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_Parent.
     * @param {Contact_ParentUpdateArgs} args - Arguments to update one Contact_Parent.
     * @example
     * // Update one Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_ParentUpdateArgs>(args: SelectSubset<T, Contact_ParentUpdateArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_Parents.
     * @param {Contact_ParentDeleteManyArgs} args - Arguments to filter Contact_Parents to delete.
     * @example
     * // Delete a few Contact_Parents
     * const { count } = await prisma.contact_Parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_ParentDeleteManyArgs>(args?: SelectSubset<T, Contact_ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_Parents
     * const contact_Parent = await prisma.contact_Parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_ParentUpdateManyArgs>(args: SelectSubset<T, Contact_ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_Parent.
     * @param {Contact_ParentUpsertArgs} args - Arguments to update or create a Contact_Parent.
     * @example
     * // Update or create a Contact_Parent
     * const contact_Parent = await prisma.contact_Parent.upsert({
     *   create: {
     *     // ... data to create a Contact_Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_Parent we want to update
     *   }
     * })
     */
    upsert<T extends Contact_ParentUpsertArgs>(args: SelectSubset<T, Contact_ParentUpsertArgs<ExtArgs>>): Prisma__Contact_ParentClient<$Result.GetResult<Prisma.$Contact_ParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentCountArgs} args - Arguments to filter Contact_Parents to count.
     * @example
     * // Count the number of Contact_Parents
     * const count = await prisma.contact_Parent.count({
     *   where: {
     *     // ... the filter for the Contact_Parents we want to count
     *   }
     * })
    **/
    count<T extends Contact_ParentCountArgs>(
      args?: Subset<T, Contact_ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_ParentAggregateArgs>(args: Subset<T, Contact_ParentAggregateArgs>): Prisma.PrismaPromise<GetContact_ParentAggregateType<T>>

    /**
     * Group by Contact_Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_ParentGroupByArgs['orderBy'] }
        : { orderBy?: Contact_ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_ParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_Parent model
   */
  readonly fields: Contact_ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_Parent model
   */ 
  interface Contact_ParentFieldRefs {
    readonly id: FieldRef<"Contact_Parent", 'Int'>
    readonly parent_contact_id: FieldRef<"Contact_Parent", 'Int'>
    readonly contact_id: FieldRef<"Contact_Parent", 'Int'>
    readonly createdAt: FieldRef<"Contact_Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact_Parent findUnique
   */
  export type Contact_ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Parent to fetch.
     */
    where: Contact_ParentWhereUniqueInput
  }

  /**
   * Contact_Parent findUniqueOrThrow
   */
  export type Contact_ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Parent to fetch.
     */
    where: Contact_ParentWhereUniqueInput
  }

  /**
   * Contact_Parent findFirst
   */
  export type Contact_ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Parent to fetch.
     */
    where?: Contact_ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Parents to fetch.
     */
    orderBy?: Contact_ParentOrderByWithRelationInput | Contact_ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Parents.
     */
    cursor?: Contact_ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Parents.
     */
    distinct?: Contact_ParentScalarFieldEnum | Contact_ParentScalarFieldEnum[]
  }

  /**
   * Contact_Parent findFirstOrThrow
   */
  export type Contact_ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Parent to fetch.
     */
    where?: Contact_ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Parents to fetch.
     */
    orderBy?: Contact_ParentOrderByWithRelationInput | Contact_ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Parents.
     */
    cursor?: Contact_ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Parents.
     */
    distinct?: Contact_ParentScalarFieldEnum | Contact_ParentScalarFieldEnum[]
  }

  /**
   * Contact_Parent findMany
   */
  export type Contact_ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Parents to fetch.
     */
    where?: Contact_ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Parents to fetch.
     */
    orderBy?: Contact_ParentOrderByWithRelationInput | Contact_ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_Parents.
     */
    cursor?: Contact_ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Parents.
     */
    skip?: number
    distinct?: Contact_ParentScalarFieldEnum | Contact_ParentScalarFieldEnum[]
  }

  /**
   * Contact_Parent create
   */
  export type Contact_ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * The data needed to create a Contact_Parent.
     */
    data: XOR<Contact_ParentCreateInput, Contact_ParentUncheckedCreateInput>
  }

  /**
   * Contact_Parent createMany
   */
  export type Contact_ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_Parents.
     */
    data: Contact_ParentCreateManyInput | Contact_ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Parent createManyAndReturn
   */
  export type Contact_ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contact_Parents.
     */
    data: Contact_ParentCreateManyInput | Contact_ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Parent update
   */
  export type Contact_ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * The data needed to update a Contact_Parent.
     */
    data: XOR<Contact_ParentUpdateInput, Contact_ParentUncheckedUpdateInput>
    /**
     * Choose, which Contact_Parent to update.
     */
    where: Contact_ParentWhereUniqueInput
  }

  /**
   * Contact_Parent updateMany
   */
  export type Contact_ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_Parents.
     */
    data: XOR<Contact_ParentUpdateManyMutationInput, Contact_ParentUncheckedUpdateManyInput>
    /**
     * Filter which Contact_Parents to update
     */
    where?: Contact_ParentWhereInput
  }

  /**
   * Contact_Parent upsert
   */
  export type Contact_ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * The filter to search for the Contact_Parent to update in case it exists.
     */
    where: Contact_ParentWhereUniqueInput
    /**
     * In case the Contact_Parent found by the `where` argument doesn't exist, create a new Contact_Parent with this data.
     */
    create: XOR<Contact_ParentCreateInput, Contact_ParentUncheckedCreateInput>
    /**
     * In case the Contact_Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_ParentUpdateInput, Contact_ParentUncheckedUpdateInput>
  }

  /**
   * Contact_Parent delete
   */
  export type Contact_ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
    /**
     * Filter which Contact_Parent to delete.
     */
    where: Contact_ParentWhereUniqueInput
  }

  /**
   * Contact_Parent deleteMany
   */
  export type Contact_ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Parents to delete
     */
    where?: Contact_ParentWhereInput
  }

  /**
   * Contact_Parent without action
   */
  export type Contact_ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Parent
     */
    select?: Contact_ParentSelect<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    contact_id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    contact_id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    contact_id: number | null
    tag: string | null
    note: string | null
    createdAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    contact_id: number | null
    tag: string | null
    note: string | null
    createdAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    contact_id: number
    tag: number
    note: number
    createdAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    contact_id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    contact_id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    contact_id?: true
    tag?: true
    note?: true
    createdAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    contact_id?: true
    tag?: true
    note?: true
    createdAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    contact_id?: true
    tag?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    contact_id: number
    tag: string
    note: string
    createdAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    tag?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    tag?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    contact_id?: boolean
    tag?: boolean
    note?: boolean
    createdAt?: boolean
  }


  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contact_id: number
      tag: string
      note: string
      createdAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly contact_id: FieldRef<"Customer", 'Int'>
    readonly tag: FieldRef<"Customer", 'String'>
    readonly note: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
  }


  /**
   * Model Contact_Note
   */

  export type AggregateContact_Note = {
    _count: Contact_NoteCountAggregateOutputType | null
    _avg: Contact_NoteAvgAggregateOutputType | null
    _sum: Contact_NoteSumAggregateOutputType | null
    _min: Contact_NoteMinAggregateOutputType | null
    _max: Contact_NoteMaxAggregateOutputType | null
  }

  export type Contact_NoteAvgAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    contact_id: number | null
  }

  export type Contact_NoteSumAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    contact_id: number | null
  }

  export type Contact_NoteMinAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    contact_id: number | null
    note: string | null
    createdAt: Date | null
  }

  export type Contact_NoteMaxAggregateOutputType = {
    id: number | null
    sub_campaign_id: number | null
    contact_id: number | null
    note: string | null
    createdAt: Date | null
  }

  export type Contact_NoteCountAggregateOutputType = {
    id: number
    sub_campaign_id: number
    contact_id: number
    note: number
    createdAt: number
    _all: number
  }


  export type Contact_NoteAvgAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    contact_id?: true
  }

  export type Contact_NoteSumAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    contact_id?: true
  }

  export type Contact_NoteMinAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    contact_id?: true
    note?: true
    createdAt?: true
  }

  export type Contact_NoteMaxAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    contact_id?: true
    note?: true
    createdAt?: true
  }

  export type Contact_NoteCountAggregateInputType = {
    id?: true
    sub_campaign_id?: true
    contact_id?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type Contact_NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Note to aggregate.
     */
    where?: Contact_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Notes to fetch.
     */
    orderBy?: Contact_NoteOrderByWithRelationInput | Contact_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_Notes
    **/
    _count?: true | Contact_NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_NoteMaxAggregateInputType
  }

  export type GetContact_NoteAggregateType<T extends Contact_NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_Note]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_Note[P]>
      : GetScalarType<T[P], AggregateContact_Note[P]>
  }




  export type Contact_NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_NoteWhereInput
    orderBy?: Contact_NoteOrderByWithAggregationInput | Contact_NoteOrderByWithAggregationInput[]
    by: Contact_NoteScalarFieldEnum[] | Contact_NoteScalarFieldEnum
    having?: Contact_NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_NoteCountAggregateInputType | true
    _avg?: Contact_NoteAvgAggregateInputType
    _sum?: Contact_NoteSumAggregateInputType
    _min?: Contact_NoteMinAggregateInputType
    _max?: Contact_NoteMaxAggregateInputType
  }

  export type Contact_NoteGroupByOutputType = {
    id: number
    sub_campaign_id: number
    contact_id: number
    note: string
    createdAt: Date
    _count: Contact_NoteCountAggregateOutputType | null
    _avg: Contact_NoteAvgAggregateOutputType | null
    _sum: Contact_NoteSumAggregateOutputType | null
    _min: Contact_NoteMinAggregateOutputType | null
    _max: Contact_NoteMaxAggregateOutputType | null
  }

  type GetContact_NoteGroupByPayload<T extends Contact_NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_NoteGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_NoteGroupByOutputType[P]>
        }
      >
    >


  export type Contact_NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_campaign_id?: boolean
    contact_id?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Note"]>

  export type Contact_NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sub_campaign_id?: boolean
    contact_id?: boolean
    note?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Note"]>

  export type Contact_NoteSelectScalar = {
    id?: boolean
    sub_campaign_id?: boolean
    contact_id?: boolean
    note?: boolean
    createdAt?: boolean
  }


  export type $Contact_NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_Note"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sub_campaign_id: number
      contact_id: number
      note: string
      createdAt: Date
    }, ExtArgs["result"]["contact_Note"]>
    composites: {}
  }

  type Contact_NoteGetPayload<S extends boolean | null | undefined | Contact_NoteDefaultArgs> = $Result.GetResult<Prisma.$Contact_NotePayload, S>

  type Contact_NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Contact_NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_NoteCountAggregateInputType | true
    }

  export interface Contact_NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_Note'], meta: { name: 'Contact_Note' } }
    /**
     * Find zero or one Contact_Note that matches the filter.
     * @param {Contact_NoteFindUniqueArgs} args - Arguments to find a Contact_Note
     * @example
     * // Get one Contact_Note
     * const contact_Note = await prisma.contact_Note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_NoteFindUniqueArgs>(args: SelectSubset<T, Contact_NoteFindUniqueArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_Note that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Contact_NoteFindUniqueOrThrowArgs} args - Arguments to find a Contact_Note
     * @example
     * // Get one Contact_Note
     * const contact_Note = await prisma.contact_Note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteFindFirstArgs} args - Arguments to find a Contact_Note
     * @example
     * // Get one Contact_Note
     * const contact_Note = await prisma.contact_Note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_NoteFindFirstArgs>(args?: SelectSubset<T, Contact_NoteFindFirstArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteFindFirstOrThrowArgs} args - Arguments to find a Contact_Note
     * @example
     * // Get one Contact_Note
     * const contact_Note = await prisma.contact_Note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_Notes
     * const contact_Notes = await prisma.contact_Note.findMany()
     * 
     * // Get first 10 Contact_Notes
     * const contact_Notes = await prisma.contact_Note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_NoteWithIdOnly = await prisma.contact_Note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_NoteFindManyArgs>(args?: SelectSubset<T, Contact_NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_Note.
     * @param {Contact_NoteCreateArgs} args - Arguments to create a Contact_Note.
     * @example
     * // Create one Contact_Note
     * const Contact_Note = await prisma.contact_Note.create({
     *   data: {
     *     // ... data to create a Contact_Note
     *   }
     * })
     * 
     */
    create<T extends Contact_NoteCreateArgs>(args: SelectSubset<T, Contact_NoteCreateArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_Notes.
     * @param {Contact_NoteCreateManyArgs} args - Arguments to create many Contact_Notes.
     * @example
     * // Create many Contact_Notes
     * const contact_Note = await prisma.contact_Note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_NoteCreateManyArgs>(args?: SelectSubset<T, Contact_NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_Notes and returns the data saved in the database.
     * @param {Contact_NoteCreateManyAndReturnArgs} args - Arguments to create many Contact_Notes.
     * @example
     * // Create many Contact_Notes
     * const contact_Note = await prisma.contact_Note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_Notes and only return the `id`
     * const contact_NoteWithIdOnly = await prisma.contact_Note.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_Note.
     * @param {Contact_NoteDeleteArgs} args - Arguments to delete one Contact_Note.
     * @example
     * // Delete one Contact_Note
     * const Contact_Note = await prisma.contact_Note.delete({
     *   where: {
     *     // ... filter to delete one Contact_Note
     *   }
     * })
     * 
     */
    delete<T extends Contact_NoteDeleteArgs>(args: SelectSubset<T, Contact_NoteDeleteArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_Note.
     * @param {Contact_NoteUpdateArgs} args - Arguments to update one Contact_Note.
     * @example
     * // Update one Contact_Note
     * const contact_Note = await prisma.contact_Note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_NoteUpdateArgs>(args: SelectSubset<T, Contact_NoteUpdateArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_Notes.
     * @param {Contact_NoteDeleteManyArgs} args - Arguments to filter Contact_Notes to delete.
     * @example
     * // Delete a few Contact_Notes
     * const { count } = await prisma.contact_Note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_NoteDeleteManyArgs>(args?: SelectSubset<T, Contact_NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_Notes
     * const contact_Note = await prisma.contact_Note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_NoteUpdateManyArgs>(args: SelectSubset<T, Contact_NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_Note.
     * @param {Contact_NoteUpsertArgs} args - Arguments to update or create a Contact_Note.
     * @example
     * // Update or create a Contact_Note
     * const contact_Note = await prisma.contact_Note.upsert({
     *   create: {
     *     // ... data to create a Contact_Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_Note we want to update
     *   }
     * })
     */
    upsert<T extends Contact_NoteUpsertArgs>(args: SelectSubset<T, Contact_NoteUpsertArgs<ExtArgs>>): Prisma__Contact_NoteClient<$Result.GetResult<Prisma.$Contact_NotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteCountArgs} args - Arguments to filter Contact_Notes to count.
     * @example
     * // Count the number of Contact_Notes
     * const count = await prisma.contact_Note.count({
     *   where: {
     *     // ... the filter for the Contact_Notes we want to count
     *   }
     * })
    **/
    count<T extends Contact_NoteCountArgs>(
      args?: Subset<T, Contact_NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_NoteAggregateArgs>(args: Subset<T, Contact_NoteAggregateArgs>): Prisma.PrismaPromise<GetContact_NoteAggregateType<T>>

    /**
     * Group by Contact_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_NoteGroupByArgs['orderBy'] }
        : { orderBy?: Contact_NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_NoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_Note model
   */
  readonly fields: Contact_NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_Note model
   */ 
  interface Contact_NoteFieldRefs {
    readonly id: FieldRef<"Contact_Note", 'Int'>
    readonly sub_campaign_id: FieldRef<"Contact_Note", 'Int'>
    readonly contact_id: FieldRef<"Contact_Note", 'Int'>
    readonly note: FieldRef<"Contact_Note", 'String'>
    readonly createdAt: FieldRef<"Contact_Note", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact_Note findUnique
   */
  export type Contact_NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Note to fetch.
     */
    where: Contact_NoteWhereUniqueInput
  }

  /**
   * Contact_Note findUniqueOrThrow
   */
  export type Contact_NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Note to fetch.
     */
    where: Contact_NoteWhereUniqueInput
  }

  /**
   * Contact_Note findFirst
   */
  export type Contact_NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Note to fetch.
     */
    where?: Contact_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Notes to fetch.
     */
    orderBy?: Contact_NoteOrderByWithRelationInput | Contact_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Notes.
     */
    cursor?: Contact_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Notes.
     */
    distinct?: Contact_NoteScalarFieldEnum | Contact_NoteScalarFieldEnum[]
  }

  /**
   * Contact_Note findFirstOrThrow
   */
  export type Contact_NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Note to fetch.
     */
    where?: Contact_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Notes to fetch.
     */
    orderBy?: Contact_NoteOrderByWithRelationInput | Contact_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Notes.
     */
    cursor?: Contact_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Notes.
     */
    distinct?: Contact_NoteScalarFieldEnum | Contact_NoteScalarFieldEnum[]
  }

  /**
   * Contact_Note findMany
   */
  export type Contact_NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Notes to fetch.
     */
    where?: Contact_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Notes to fetch.
     */
    orderBy?: Contact_NoteOrderByWithRelationInput | Contact_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_Notes.
     */
    cursor?: Contact_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Notes.
     */
    skip?: number
    distinct?: Contact_NoteScalarFieldEnum | Contact_NoteScalarFieldEnum[]
  }

  /**
   * Contact_Note create
   */
  export type Contact_NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * The data needed to create a Contact_Note.
     */
    data: XOR<Contact_NoteCreateInput, Contact_NoteUncheckedCreateInput>
  }

  /**
   * Contact_Note createMany
   */
  export type Contact_NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_Notes.
     */
    data: Contact_NoteCreateManyInput | Contact_NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Note createManyAndReturn
   */
  export type Contact_NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contact_Notes.
     */
    data: Contact_NoteCreateManyInput | Contact_NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Note update
   */
  export type Contact_NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * The data needed to update a Contact_Note.
     */
    data: XOR<Contact_NoteUpdateInput, Contact_NoteUncheckedUpdateInput>
    /**
     * Choose, which Contact_Note to update.
     */
    where: Contact_NoteWhereUniqueInput
  }

  /**
   * Contact_Note updateMany
   */
  export type Contact_NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_Notes.
     */
    data: XOR<Contact_NoteUpdateManyMutationInput, Contact_NoteUncheckedUpdateManyInput>
    /**
     * Filter which Contact_Notes to update
     */
    where?: Contact_NoteWhereInput
  }

  /**
   * Contact_Note upsert
   */
  export type Contact_NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * The filter to search for the Contact_Note to update in case it exists.
     */
    where: Contact_NoteWhereUniqueInput
    /**
     * In case the Contact_Note found by the `where` argument doesn't exist, create a new Contact_Note with this data.
     */
    create: XOR<Contact_NoteCreateInput, Contact_NoteUncheckedCreateInput>
    /**
     * In case the Contact_Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_NoteUpdateInput, Contact_NoteUncheckedUpdateInput>
  }

  /**
   * Contact_Note delete
   */
  export type Contact_NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
    /**
     * Filter which Contact_Note to delete.
     */
    where: Contact_NoteWhereUniqueInput
  }

  /**
   * Contact_Note deleteMany
   */
  export type Contact_NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Notes to delete
     */
    where?: Contact_NoteWhereInput
  }

  /**
   * Contact_Note without action
   */
  export type Contact_NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Note
     */
    select?: Contact_NoteSelect<ExtArgs> | null
  }


  /**
   * Model Contact_Activity
   */

  export type AggregateContact_Activity = {
    _count: Contact_ActivityCountAggregateOutputType | null
    _avg: Contact_ActivityAvgAggregateOutputType | null
    _sum: Contact_ActivitySumAggregateOutputType | null
    _min: Contact_ActivityMinAggregateOutputType | null
    _max: Contact_ActivityMaxAggregateOutputType | null
  }

  export type Contact_ActivityAvgAggregateOutputType = {
    id: number | null
    contact_id: number | null
  }

  export type Contact_ActivitySumAggregateOutputType = {
    id: number | null
    contact_id: number | null
  }

  export type Contact_ActivityMinAggregateOutputType = {
    id: number | null
    contact_id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type Contact_ActivityMaxAggregateOutputType = {
    id: number | null
    contact_id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type Contact_ActivityCountAggregateOutputType = {
    id: number
    contact_id: number
    title: number
    description: number
    createdAt: number
    _all: number
  }


  export type Contact_ActivityAvgAggregateInputType = {
    id?: true
    contact_id?: true
  }

  export type Contact_ActivitySumAggregateInputType = {
    id?: true
    contact_id?: true
  }

  export type Contact_ActivityMinAggregateInputType = {
    id?: true
    contact_id?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type Contact_ActivityMaxAggregateInputType = {
    id?: true
    contact_id?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type Contact_ActivityCountAggregateInputType = {
    id?: true
    contact_id?: true
    title?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type Contact_ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Activity to aggregate.
     */
    where?: Contact_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Activities to fetch.
     */
    orderBy?: Contact_ActivityOrderByWithRelationInput | Contact_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_Activities
    **/
    _count?: true | Contact_ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_ActivityMaxAggregateInputType
  }

  export type GetContact_ActivityAggregateType<T extends Contact_ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_Activity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_Activity[P]>
      : GetScalarType<T[P], AggregateContact_Activity[P]>
  }




  export type Contact_ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_ActivityWhereInput
    orderBy?: Contact_ActivityOrderByWithAggregationInput | Contact_ActivityOrderByWithAggregationInput[]
    by: Contact_ActivityScalarFieldEnum[] | Contact_ActivityScalarFieldEnum
    having?: Contact_ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_ActivityCountAggregateInputType | true
    _avg?: Contact_ActivityAvgAggregateInputType
    _sum?: Contact_ActivitySumAggregateInputType
    _min?: Contact_ActivityMinAggregateInputType
    _max?: Contact_ActivityMaxAggregateInputType
  }

  export type Contact_ActivityGroupByOutputType = {
    id: number
    contact_id: number
    title: string
    description: string
    createdAt: Date
    _count: Contact_ActivityCountAggregateOutputType | null
    _avg: Contact_ActivityAvgAggregateOutputType | null
    _sum: Contact_ActivitySumAggregateOutputType | null
    _min: Contact_ActivityMinAggregateOutputType | null
    _max: Contact_ActivityMaxAggregateOutputType | null
  }

  type GetContact_ActivityGroupByPayload<T extends Contact_ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_ActivityGroupByOutputType[P]>
        }
      >
    >


  export type Contact_ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Activity"]>

  export type Contact_ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Activity"]>

  export type Contact_ActivitySelectScalar = {
    id?: boolean
    contact_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }


  export type $Contact_ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_Activity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contact_id: number
      title: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["contact_Activity"]>
    composites: {}
  }

  type Contact_ActivityGetPayload<S extends boolean | null | undefined | Contact_ActivityDefaultArgs> = $Result.GetResult<Prisma.$Contact_ActivityPayload, S>

  type Contact_ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Contact_ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_ActivityCountAggregateInputType | true
    }

  export interface Contact_ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_Activity'], meta: { name: 'Contact_Activity' } }
    /**
     * Find zero or one Contact_Activity that matches the filter.
     * @param {Contact_ActivityFindUniqueArgs} args - Arguments to find a Contact_Activity
     * @example
     * // Get one Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_ActivityFindUniqueArgs>(args: SelectSubset<T, Contact_ActivityFindUniqueArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Contact_ActivityFindUniqueOrThrowArgs} args - Arguments to find a Contact_Activity
     * @example
     * // Get one Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityFindFirstArgs} args - Arguments to find a Contact_Activity
     * @example
     * // Get one Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_ActivityFindFirstArgs>(args?: SelectSubset<T, Contact_ActivityFindFirstArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityFindFirstOrThrowArgs} args - Arguments to find a Contact_Activity
     * @example
     * // Get one Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_Activities
     * const contact_Activities = await prisma.contact_Activity.findMany()
     * 
     * // Get first 10 Contact_Activities
     * const contact_Activities = await prisma.contact_Activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_ActivityWithIdOnly = await prisma.contact_Activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_ActivityFindManyArgs>(args?: SelectSubset<T, Contact_ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_Activity.
     * @param {Contact_ActivityCreateArgs} args - Arguments to create a Contact_Activity.
     * @example
     * // Create one Contact_Activity
     * const Contact_Activity = await prisma.contact_Activity.create({
     *   data: {
     *     // ... data to create a Contact_Activity
     *   }
     * })
     * 
     */
    create<T extends Contact_ActivityCreateArgs>(args: SelectSubset<T, Contact_ActivityCreateArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_Activities.
     * @param {Contact_ActivityCreateManyArgs} args - Arguments to create many Contact_Activities.
     * @example
     * // Create many Contact_Activities
     * const contact_Activity = await prisma.contact_Activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_ActivityCreateManyArgs>(args?: SelectSubset<T, Contact_ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_Activities and returns the data saved in the database.
     * @param {Contact_ActivityCreateManyAndReturnArgs} args - Arguments to create many Contact_Activities.
     * @example
     * // Create many Contact_Activities
     * const contact_Activity = await prisma.contact_Activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_Activities and only return the `id`
     * const contact_ActivityWithIdOnly = await prisma.contact_Activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_Activity.
     * @param {Contact_ActivityDeleteArgs} args - Arguments to delete one Contact_Activity.
     * @example
     * // Delete one Contact_Activity
     * const Contact_Activity = await prisma.contact_Activity.delete({
     *   where: {
     *     // ... filter to delete one Contact_Activity
     *   }
     * })
     * 
     */
    delete<T extends Contact_ActivityDeleteArgs>(args: SelectSubset<T, Contact_ActivityDeleteArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_Activity.
     * @param {Contact_ActivityUpdateArgs} args - Arguments to update one Contact_Activity.
     * @example
     * // Update one Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_ActivityUpdateArgs>(args: SelectSubset<T, Contact_ActivityUpdateArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_Activities.
     * @param {Contact_ActivityDeleteManyArgs} args - Arguments to filter Contact_Activities to delete.
     * @example
     * // Delete a few Contact_Activities
     * const { count } = await prisma.contact_Activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_ActivityDeleteManyArgs>(args?: SelectSubset<T, Contact_ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_Activities
     * const contact_Activity = await prisma.contact_Activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_ActivityUpdateManyArgs>(args: SelectSubset<T, Contact_ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_Activity.
     * @param {Contact_ActivityUpsertArgs} args - Arguments to update or create a Contact_Activity.
     * @example
     * // Update or create a Contact_Activity
     * const contact_Activity = await prisma.contact_Activity.upsert({
     *   create: {
     *     // ... data to create a Contact_Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_Activity we want to update
     *   }
     * })
     */
    upsert<T extends Contact_ActivityUpsertArgs>(args: SelectSubset<T, Contact_ActivityUpsertArgs<ExtArgs>>): Prisma__Contact_ActivityClient<$Result.GetResult<Prisma.$Contact_ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityCountArgs} args - Arguments to filter Contact_Activities to count.
     * @example
     * // Count the number of Contact_Activities
     * const count = await prisma.contact_Activity.count({
     *   where: {
     *     // ... the filter for the Contact_Activities we want to count
     *   }
     * })
    **/
    count<T extends Contact_ActivityCountArgs>(
      args?: Subset<T, Contact_ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_ActivityAggregateArgs>(args: Subset<T, Contact_ActivityAggregateArgs>): Prisma.PrismaPromise<GetContact_ActivityAggregateType<T>>

    /**
     * Group by Contact_Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_ActivityGroupByArgs['orderBy'] }
        : { orderBy?: Contact_ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_ActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_Activity model
   */
  readonly fields: Contact_ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_Activity model
   */ 
  interface Contact_ActivityFieldRefs {
    readonly id: FieldRef<"Contact_Activity", 'Int'>
    readonly contact_id: FieldRef<"Contact_Activity", 'Int'>
    readonly title: FieldRef<"Contact_Activity", 'String'>
    readonly description: FieldRef<"Contact_Activity", 'String'>
    readonly createdAt: FieldRef<"Contact_Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact_Activity findUnique
   */
  export type Contact_ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter, which Contact_Activity to fetch.
     */
    where: Contact_ActivityWhereUniqueInput
  }

  /**
   * Contact_Activity findUniqueOrThrow
   */
  export type Contact_ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter, which Contact_Activity to fetch.
     */
    where: Contact_ActivityWhereUniqueInput
  }

  /**
   * Contact_Activity findFirst
   */
  export type Contact_ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter, which Contact_Activity to fetch.
     */
    where?: Contact_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Activities to fetch.
     */
    orderBy?: Contact_ActivityOrderByWithRelationInput | Contact_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Activities.
     */
    cursor?: Contact_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Activities.
     */
    distinct?: Contact_ActivityScalarFieldEnum | Contact_ActivityScalarFieldEnum[]
  }

  /**
   * Contact_Activity findFirstOrThrow
   */
  export type Contact_ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter, which Contact_Activity to fetch.
     */
    where?: Contact_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Activities to fetch.
     */
    orderBy?: Contact_ActivityOrderByWithRelationInput | Contact_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Activities.
     */
    cursor?: Contact_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Activities.
     */
    distinct?: Contact_ActivityScalarFieldEnum | Contact_ActivityScalarFieldEnum[]
  }

  /**
   * Contact_Activity findMany
   */
  export type Contact_ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter, which Contact_Activities to fetch.
     */
    where?: Contact_ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Activities to fetch.
     */
    orderBy?: Contact_ActivityOrderByWithRelationInput | Contact_ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_Activities.
     */
    cursor?: Contact_ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Activities.
     */
    skip?: number
    distinct?: Contact_ActivityScalarFieldEnum | Contact_ActivityScalarFieldEnum[]
  }

  /**
   * Contact_Activity create
   */
  export type Contact_ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * The data needed to create a Contact_Activity.
     */
    data: XOR<Contact_ActivityCreateInput, Contact_ActivityUncheckedCreateInput>
  }

  /**
   * Contact_Activity createMany
   */
  export type Contact_ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_Activities.
     */
    data: Contact_ActivityCreateManyInput | Contact_ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Activity createManyAndReturn
   */
  export type Contact_ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contact_Activities.
     */
    data: Contact_ActivityCreateManyInput | Contact_ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Activity update
   */
  export type Contact_ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * The data needed to update a Contact_Activity.
     */
    data: XOR<Contact_ActivityUpdateInput, Contact_ActivityUncheckedUpdateInput>
    /**
     * Choose, which Contact_Activity to update.
     */
    where: Contact_ActivityWhereUniqueInput
  }

  /**
   * Contact_Activity updateMany
   */
  export type Contact_ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_Activities.
     */
    data: XOR<Contact_ActivityUpdateManyMutationInput, Contact_ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Contact_Activities to update
     */
    where?: Contact_ActivityWhereInput
  }

  /**
   * Contact_Activity upsert
   */
  export type Contact_ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * The filter to search for the Contact_Activity to update in case it exists.
     */
    where: Contact_ActivityWhereUniqueInput
    /**
     * In case the Contact_Activity found by the `where` argument doesn't exist, create a new Contact_Activity with this data.
     */
    create: XOR<Contact_ActivityCreateInput, Contact_ActivityUncheckedCreateInput>
    /**
     * In case the Contact_Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_ActivityUpdateInput, Contact_ActivityUncheckedUpdateInput>
  }

  /**
   * Contact_Activity delete
   */
  export type Contact_ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
    /**
     * Filter which Contact_Activity to delete.
     */
    where: Contact_ActivityWhereUniqueInput
  }

  /**
   * Contact_Activity deleteMany
   */
  export type Contact_ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Activities to delete
     */
    where?: Contact_ActivityWhereInput
  }

  /**
   * Contact_Activity without action
   */
  export type Contact_ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Activity
     */
    select?: Contact_ActivitySelect<ExtArgs> | null
  }


  /**
   * Model Contact_Bant
   */

  export type AggregateContact_Bant = {
    _count: Contact_BantCountAggregateOutputType | null
    _avg: Contact_BantAvgAggregateOutputType | null
    _sum: Contact_BantSumAggregateOutputType | null
    _min: Contact_BantMinAggregateOutputType | null
    _max: Contact_BantMaxAggregateOutputType | null
  }

  export type Contact_BantAvgAggregateOutputType = {
    id: number | null
    contact_id: number | null
    lead_type: number | null
    lead_owner: number | null
  }

  export type Contact_BantSumAggregateOutputType = {
    id: number | null
    contact_id: number | null
    lead_type: number | null
    lead_owner: number | null
  }

  export type Contact_BantMinAggregateOutputType = {
    id: number | null
    contact_id: number | null
    lead_type: number | null
    lead_owner: number | null
    budget: string | null
    authority: string | null
    need: string | null
    time: string | null
    spesification_project: string | null
    next_step: string | null
    createdAt: Date | null
  }

  export type Contact_BantMaxAggregateOutputType = {
    id: number | null
    contact_id: number | null
    lead_type: number | null
    lead_owner: number | null
    budget: string | null
    authority: string | null
    need: string | null
    time: string | null
    spesification_project: string | null
    next_step: string | null
    createdAt: Date | null
  }

  export type Contact_BantCountAggregateOutputType = {
    id: number
    contact_id: number
    lead_type: number
    lead_owner: number
    budget: number
    authority: number
    need: number
    time: number
    spesification_project: number
    next_step: number
    createdAt: number
    _all: number
  }


  export type Contact_BantAvgAggregateInputType = {
    id?: true
    contact_id?: true
    lead_type?: true
    lead_owner?: true
  }

  export type Contact_BantSumAggregateInputType = {
    id?: true
    contact_id?: true
    lead_type?: true
    lead_owner?: true
  }

  export type Contact_BantMinAggregateInputType = {
    id?: true
    contact_id?: true
    lead_type?: true
    lead_owner?: true
    budget?: true
    authority?: true
    need?: true
    time?: true
    spesification_project?: true
    next_step?: true
    createdAt?: true
  }

  export type Contact_BantMaxAggregateInputType = {
    id?: true
    contact_id?: true
    lead_type?: true
    lead_owner?: true
    budget?: true
    authority?: true
    need?: true
    time?: true
    spesification_project?: true
    next_step?: true
    createdAt?: true
  }

  export type Contact_BantCountAggregateInputType = {
    id?: true
    contact_id?: true
    lead_type?: true
    lead_owner?: true
    budget?: true
    authority?: true
    need?: true
    time?: true
    spesification_project?: true
    next_step?: true
    createdAt?: true
    _all?: true
  }

  export type Contact_BantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Bant to aggregate.
     */
    where?: Contact_BantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Bants to fetch.
     */
    orderBy?: Contact_BantOrderByWithRelationInput | Contact_BantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_BantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Bants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Bants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_Bants
    **/
    _count?: true | Contact_BantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_BantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_BantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_BantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_BantMaxAggregateInputType
  }

  export type GetContact_BantAggregateType<T extends Contact_BantAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_Bant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_Bant[P]>
      : GetScalarType<T[P], AggregateContact_Bant[P]>
  }




  export type Contact_BantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_BantWhereInput
    orderBy?: Contact_BantOrderByWithAggregationInput | Contact_BantOrderByWithAggregationInput[]
    by: Contact_BantScalarFieldEnum[] | Contact_BantScalarFieldEnum
    having?: Contact_BantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_BantCountAggregateInputType | true
    _avg?: Contact_BantAvgAggregateInputType
    _sum?: Contact_BantSumAggregateInputType
    _min?: Contact_BantMinAggregateInputType
    _max?: Contact_BantMaxAggregateInputType
  }

  export type Contact_BantGroupByOutputType = {
    id: number
    contact_id: number
    lead_type: number
    lead_owner: number
    budget: string
    authority: string
    need: string
    time: string
    spesification_project: string
    next_step: string
    createdAt: Date
    _count: Contact_BantCountAggregateOutputType | null
    _avg: Contact_BantAvgAggregateOutputType | null
    _sum: Contact_BantSumAggregateOutputType | null
    _min: Contact_BantMinAggregateOutputType | null
    _max: Contact_BantMaxAggregateOutputType | null
  }

  type GetContact_BantGroupByPayload<T extends Contact_BantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_BantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_BantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_BantGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_BantGroupByOutputType[P]>
        }
      >
    >


  export type Contact_BantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    lead_type?: boolean
    lead_owner?: boolean
    budget?: boolean
    authority?: boolean
    need?: boolean
    time?: boolean
    spesification_project?: boolean
    next_step?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Bant"]>

  export type Contact_BantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    lead_type?: boolean
    lead_owner?: boolean
    budget?: boolean
    authority?: boolean
    need?: boolean
    time?: boolean
    spesification_project?: boolean
    next_step?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Bant"]>

  export type Contact_BantSelectScalar = {
    id?: boolean
    contact_id?: boolean
    lead_type?: boolean
    lead_owner?: boolean
    budget?: boolean
    authority?: boolean
    need?: boolean
    time?: boolean
    spesification_project?: boolean
    next_step?: boolean
    createdAt?: boolean
  }


  export type $Contact_BantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_Bant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contact_id: number
      lead_type: number
      lead_owner: number
      budget: string
      authority: string
      need: string
      time: string
      spesification_project: string
      next_step: string
      createdAt: Date
    }, ExtArgs["result"]["contact_Bant"]>
    composites: {}
  }

  type Contact_BantGetPayload<S extends boolean | null | undefined | Contact_BantDefaultArgs> = $Result.GetResult<Prisma.$Contact_BantPayload, S>

  type Contact_BantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Contact_BantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_BantCountAggregateInputType | true
    }

  export interface Contact_BantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_Bant'], meta: { name: 'Contact_Bant' } }
    /**
     * Find zero or one Contact_Bant that matches the filter.
     * @param {Contact_BantFindUniqueArgs} args - Arguments to find a Contact_Bant
     * @example
     * // Get one Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_BantFindUniqueArgs>(args: SelectSubset<T, Contact_BantFindUniqueArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_Bant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Contact_BantFindUniqueOrThrowArgs} args - Arguments to find a Contact_Bant
     * @example
     * // Get one Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_BantFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_BantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_Bant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantFindFirstArgs} args - Arguments to find a Contact_Bant
     * @example
     * // Get one Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_BantFindFirstArgs>(args?: SelectSubset<T, Contact_BantFindFirstArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_Bant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantFindFirstOrThrowArgs} args - Arguments to find a Contact_Bant
     * @example
     * // Get one Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_BantFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_BantFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_Bants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_Bants
     * const contact_Bants = await prisma.contact_Bant.findMany()
     * 
     * // Get first 10 Contact_Bants
     * const contact_Bants = await prisma.contact_Bant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_BantWithIdOnly = await prisma.contact_Bant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_BantFindManyArgs>(args?: SelectSubset<T, Contact_BantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_Bant.
     * @param {Contact_BantCreateArgs} args - Arguments to create a Contact_Bant.
     * @example
     * // Create one Contact_Bant
     * const Contact_Bant = await prisma.contact_Bant.create({
     *   data: {
     *     // ... data to create a Contact_Bant
     *   }
     * })
     * 
     */
    create<T extends Contact_BantCreateArgs>(args: SelectSubset<T, Contact_BantCreateArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_Bants.
     * @param {Contact_BantCreateManyArgs} args - Arguments to create many Contact_Bants.
     * @example
     * // Create many Contact_Bants
     * const contact_Bant = await prisma.contact_Bant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_BantCreateManyArgs>(args?: SelectSubset<T, Contact_BantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_Bants and returns the data saved in the database.
     * @param {Contact_BantCreateManyAndReturnArgs} args - Arguments to create many Contact_Bants.
     * @example
     * // Create many Contact_Bants
     * const contact_Bant = await prisma.contact_Bant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_Bants and only return the `id`
     * const contact_BantWithIdOnly = await prisma.contact_Bant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_BantCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_BantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_Bant.
     * @param {Contact_BantDeleteArgs} args - Arguments to delete one Contact_Bant.
     * @example
     * // Delete one Contact_Bant
     * const Contact_Bant = await prisma.contact_Bant.delete({
     *   where: {
     *     // ... filter to delete one Contact_Bant
     *   }
     * })
     * 
     */
    delete<T extends Contact_BantDeleteArgs>(args: SelectSubset<T, Contact_BantDeleteArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_Bant.
     * @param {Contact_BantUpdateArgs} args - Arguments to update one Contact_Bant.
     * @example
     * // Update one Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_BantUpdateArgs>(args: SelectSubset<T, Contact_BantUpdateArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_Bants.
     * @param {Contact_BantDeleteManyArgs} args - Arguments to filter Contact_Bants to delete.
     * @example
     * // Delete a few Contact_Bants
     * const { count } = await prisma.contact_Bant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_BantDeleteManyArgs>(args?: SelectSubset<T, Contact_BantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_Bants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_Bants
     * const contact_Bant = await prisma.contact_Bant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_BantUpdateManyArgs>(args: SelectSubset<T, Contact_BantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_Bant.
     * @param {Contact_BantUpsertArgs} args - Arguments to update or create a Contact_Bant.
     * @example
     * // Update or create a Contact_Bant
     * const contact_Bant = await prisma.contact_Bant.upsert({
     *   create: {
     *     // ... data to create a Contact_Bant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_Bant we want to update
     *   }
     * })
     */
    upsert<T extends Contact_BantUpsertArgs>(args: SelectSubset<T, Contact_BantUpsertArgs<ExtArgs>>): Prisma__Contact_BantClient<$Result.GetResult<Prisma.$Contact_BantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_Bants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantCountArgs} args - Arguments to filter Contact_Bants to count.
     * @example
     * // Count the number of Contact_Bants
     * const count = await prisma.contact_Bant.count({
     *   where: {
     *     // ... the filter for the Contact_Bants we want to count
     *   }
     * })
    **/
    count<T extends Contact_BantCountArgs>(
      args?: Subset<T, Contact_BantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_BantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_Bant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_BantAggregateArgs>(args: Subset<T, Contact_BantAggregateArgs>): Prisma.PrismaPromise<GetContact_BantAggregateType<T>>

    /**
     * Group by Contact_Bant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_BantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_BantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_BantGroupByArgs['orderBy'] }
        : { orderBy?: Contact_BantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_BantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_BantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_Bant model
   */
  readonly fields: Contact_BantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_Bant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_BantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_Bant model
   */ 
  interface Contact_BantFieldRefs {
    readonly id: FieldRef<"Contact_Bant", 'Int'>
    readonly contact_id: FieldRef<"Contact_Bant", 'Int'>
    readonly lead_type: FieldRef<"Contact_Bant", 'Int'>
    readonly lead_owner: FieldRef<"Contact_Bant", 'Int'>
    readonly budget: FieldRef<"Contact_Bant", 'String'>
    readonly authority: FieldRef<"Contact_Bant", 'String'>
    readonly need: FieldRef<"Contact_Bant", 'String'>
    readonly time: FieldRef<"Contact_Bant", 'String'>
    readonly spesification_project: FieldRef<"Contact_Bant", 'String'>
    readonly next_step: FieldRef<"Contact_Bant", 'String'>
    readonly createdAt: FieldRef<"Contact_Bant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact_Bant findUnique
   */
  export type Contact_BantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Bant to fetch.
     */
    where: Contact_BantWhereUniqueInput
  }

  /**
   * Contact_Bant findUniqueOrThrow
   */
  export type Contact_BantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Bant to fetch.
     */
    where: Contact_BantWhereUniqueInput
  }

  /**
   * Contact_Bant findFirst
   */
  export type Contact_BantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Bant to fetch.
     */
    where?: Contact_BantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Bants to fetch.
     */
    orderBy?: Contact_BantOrderByWithRelationInput | Contact_BantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Bants.
     */
    cursor?: Contact_BantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Bants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Bants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Bants.
     */
    distinct?: Contact_BantScalarFieldEnum | Contact_BantScalarFieldEnum[]
  }

  /**
   * Contact_Bant findFirstOrThrow
   */
  export type Contact_BantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Bant to fetch.
     */
    where?: Contact_BantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Bants to fetch.
     */
    orderBy?: Contact_BantOrderByWithRelationInput | Contact_BantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Bants.
     */
    cursor?: Contact_BantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Bants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Bants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Bants.
     */
    distinct?: Contact_BantScalarFieldEnum | Contact_BantScalarFieldEnum[]
  }

  /**
   * Contact_Bant findMany
   */
  export type Contact_BantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Bants to fetch.
     */
    where?: Contact_BantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Bants to fetch.
     */
    orderBy?: Contact_BantOrderByWithRelationInput | Contact_BantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_Bants.
     */
    cursor?: Contact_BantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Bants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Bants.
     */
    skip?: number
    distinct?: Contact_BantScalarFieldEnum | Contact_BantScalarFieldEnum[]
  }

  /**
   * Contact_Bant create
   */
  export type Contact_BantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * The data needed to create a Contact_Bant.
     */
    data: XOR<Contact_BantCreateInput, Contact_BantUncheckedCreateInput>
  }

  /**
   * Contact_Bant createMany
   */
  export type Contact_BantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_Bants.
     */
    data: Contact_BantCreateManyInput | Contact_BantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Bant createManyAndReturn
   */
  export type Contact_BantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contact_Bants.
     */
    data: Contact_BantCreateManyInput | Contact_BantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Bant update
   */
  export type Contact_BantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * The data needed to update a Contact_Bant.
     */
    data: XOR<Contact_BantUpdateInput, Contact_BantUncheckedUpdateInput>
    /**
     * Choose, which Contact_Bant to update.
     */
    where: Contact_BantWhereUniqueInput
  }

  /**
   * Contact_Bant updateMany
   */
  export type Contact_BantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_Bants.
     */
    data: XOR<Contact_BantUpdateManyMutationInput, Contact_BantUncheckedUpdateManyInput>
    /**
     * Filter which Contact_Bants to update
     */
    where?: Contact_BantWhereInput
  }

  /**
   * Contact_Bant upsert
   */
  export type Contact_BantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * The filter to search for the Contact_Bant to update in case it exists.
     */
    where: Contact_BantWhereUniqueInput
    /**
     * In case the Contact_Bant found by the `where` argument doesn't exist, create a new Contact_Bant with this data.
     */
    create: XOR<Contact_BantCreateInput, Contact_BantUncheckedCreateInput>
    /**
     * In case the Contact_Bant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_BantUpdateInput, Contact_BantUncheckedUpdateInput>
  }

  /**
   * Contact_Bant delete
   */
  export type Contact_BantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
    /**
     * Filter which Contact_Bant to delete.
     */
    where: Contact_BantWhereUniqueInput
  }

  /**
   * Contact_Bant deleteMany
   */
  export type Contact_BantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Bants to delete
     */
    where?: Contact_BantWhereInput
  }

  /**
   * Contact_Bant without action
   */
  export type Contact_BantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Bant
     */
    select?: Contact_BantSelect<ExtArgs> | null
  }


  /**
   * Model Contact_Timeline
   */

  export type AggregateContact_Timeline = {
    _count: Contact_TimelineCountAggregateOutputType | null
    _avg: Contact_TimelineAvgAggregateOutputType | null
    _sum: Contact_TimelineSumAggregateOutputType | null
    _min: Contact_TimelineMinAggregateOutputType | null
    _max: Contact_TimelineMaxAggregateOutputType | null
  }

  export type Contact_TimelineAvgAggregateOutputType = {
    id: number | null
    contact_id: number | null
    sub_campaign_id: number | null
  }

  export type Contact_TimelineSumAggregateOutputType = {
    id: number | null
    contact_id: number | null
    sub_campaign_id: number | null
  }

  export type Contact_TimelineMinAggregateOutputType = {
    id: number | null
    contact_id: number | null
    sub_campaign_id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type Contact_TimelineMaxAggregateOutputType = {
    id: number | null
    contact_id: number | null
    sub_campaign_id: number | null
    title: string | null
    description: string | null
    createdAt: Date | null
  }

  export type Contact_TimelineCountAggregateOutputType = {
    id: number
    contact_id: number
    sub_campaign_id: number
    title: number
    description: number
    createdAt: number
    _all: number
  }


  export type Contact_TimelineAvgAggregateInputType = {
    id?: true
    contact_id?: true
    sub_campaign_id?: true
  }

  export type Contact_TimelineSumAggregateInputType = {
    id?: true
    contact_id?: true
    sub_campaign_id?: true
  }

  export type Contact_TimelineMinAggregateInputType = {
    id?: true
    contact_id?: true
    sub_campaign_id?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type Contact_TimelineMaxAggregateInputType = {
    id?: true
    contact_id?: true
    sub_campaign_id?: true
    title?: true
    description?: true
    createdAt?: true
  }

  export type Contact_TimelineCountAggregateInputType = {
    id?: true
    contact_id?: true
    sub_campaign_id?: true
    title?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type Contact_TimelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Timeline to aggregate.
     */
    where?: Contact_TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Timelines to fetch.
     */
    orderBy?: Contact_TimelineOrderByWithRelationInput | Contact_TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Contact_TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contact_Timelines
    **/
    _count?: true | Contact_TimelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Contact_TimelineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Contact_TimelineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Contact_TimelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Contact_TimelineMaxAggregateInputType
  }

  export type GetContact_TimelineAggregateType<T extends Contact_TimelineAggregateArgs> = {
        [P in keyof T & keyof AggregateContact_Timeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact_Timeline[P]>
      : GetScalarType<T[P], AggregateContact_Timeline[P]>
  }




  export type Contact_TimelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Contact_TimelineWhereInput
    orderBy?: Contact_TimelineOrderByWithAggregationInput | Contact_TimelineOrderByWithAggregationInput[]
    by: Contact_TimelineScalarFieldEnum[] | Contact_TimelineScalarFieldEnum
    having?: Contact_TimelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Contact_TimelineCountAggregateInputType | true
    _avg?: Contact_TimelineAvgAggregateInputType
    _sum?: Contact_TimelineSumAggregateInputType
    _min?: Contact_TimelineMinAggregateInputType
    _max?: Contact_TimelineMaxAggregateInputType
  }

  export type Contact_TimelineGroupByOutputType = {
    id: number
    contact_id: number
    sub_campaign_id: number
    title: string
    description: string
    createdAt: Date
    _count: Contact_TimelineCountAggregateOutputType | null
    _avg: Contact_TimelineAvgAggregateOutputType | null
    _sum: Contact_TimelineSumAggregateOutputType | null
    _min: Contact_TimelineMinAggregateOutputType | null
    _max: Contact_TimelineMaxAggregateOutputType | null
  }

  type GetContact_TimelineGroupByPayload<T extends Contact_TimelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Contact_TimelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Contact_TimelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Contact_TimelineGroupByOutputType[P]>
            : GetScalarType<T[P], Contact_TimelineGroupByOutputType[P]>
        }
      >
    >


  export type Contact_TimelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    sub_campaign_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Timeline"]>

  export type Contact_TimelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contact_id?: boolean
    sub_campaign_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contact_Timeline"]>

  export type Contact_TimelineSelectScalar = {
    id?: boolean
    contact_id?: boolean
    sub_campaign_id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
  }


  export type $Contact_TimelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact_Timeline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contact_id: number
      sub_campaign_id: number
      title: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["contact_Timeline"]>
    composites: {}
  }

  type Contact_TimelineGetPayload<S extends boolean | null | undefined | Contact_TimelineDefaultArgs> = $Result.GetResult<Prisma.$Contact_TimelinePayload, S>

  type Contact_TimelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Contact_TimelineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Contact_TimelineCountAggregateInputType | true
    }

  export interface Contact_TimelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact_Timeline'], meta: { name: 'Contact_Timeline' } }
    /**
     * Find zero or one Contact_Timeline that matches the filter.
     * @param {Contact_TimelineFindUniqueArgs} args - Arguments to find a Contact_Timeline
     * @example
     * // Get one Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Contact_TimelineFindUniqueArgs>(args: SelectSubset<T, Contact_TimelineFindUniqueArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contact_Timeline that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Contact_TimelineFindUniqueOrThrowArgs} args - Arguments to find a Contact_Timeline
     * @example
     * // Get one Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Contact_TimelineFindUniqueOrThrowArgs>(args: SelectSubset<T, Contact_TimelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contact_Timeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineFindFirstArgs} args - Arguments to find a Contact_Timeline
     * @example
     * // Get one Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Contact_TimelineFindFirstArgs>(args?: SelectSubset<T, Contact_TimelineFindFirstArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contact_Timeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineFindFirstOrThrowArgs} args - Arguments to find a Contact_Timeline
     * @example
     * // Get one Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Contact_TimelineFindFirstOrThrowArgs>(args?: SelectSubset<T, Contact_TimelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contact_Timelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contact_Timelines
     * const contact_Timelines = await prisma.contact_Timeline.findMany()
     * 
     * // Get first 10 Contact_Timelines
     * const contact_Timelines = await prisma.contact_Timeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contact_TimelineWithIdOnly = await prisma.contact_Timeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Contact_TimelineFindManyArgs>(args?: SelectSubset<T, Contact_TimelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contact_Timeline.
     * @param {Contact_TimelineCreateArgs} args - Arguments to create a Contact_Timeline.
     * @example
     * // Create one Contact_Timeline
     * const Contact_Timeline = await prisma.contact_Timeline.create({
     *   data: {
     *     // ... data to create a Contact_Timeline
     *   }
     * })
     * 
     */
    create<T extends Contact_TimelineCreateArgs>(args: SelectSubset<T, Contact_TimelineCreateArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contact_Timelines.
     * @param {Contact_TimelineCreateManyArgs} args - Arguments to create many Contact_Timelines.
     * @example
     * // Create many Contact_Timelines
     * const contact_Timeline = await prisma.contact_Timeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Contact_TimelineCreateManyArgs>(args?: SelectSubset<T, Contact_TimelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contact_Timelines and returns the data saved in the database.
     * @param {Contact_TimelineCreateManyAndReturnArgs} args - Arguments to create many Contact_Timelines.
     * @example
     * // Create many Contact_Timelines
     * const contact_Timeline = await prisma.contact_Timeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contact_Timelines and only return the `id`
     * const contact_TimelineWithIdOnly = await prisma.contact_Timeline.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Contact_TimelineCreateManyAndReturnArgs>(args?: SelectSubset<T, Contact_TimelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contact_Timeline.
     * @param {Contact_TimelineDeleteArgs} args - Arguments to delete one Contact_Timeline.
     * @example
     * // Delete one Contact_Timeline
     * const Contact_Timeline = await prisma.contact_Timeline.delete({
     *   where: {
     *     // ... filter to delete one Contact_Timeline
     *   }
     * })
     * 
     */
    delete<T extends Contact_TimelineDeleteArgs>(args: SelectSubset<T, Contact_TimelineDeleteArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contact_Timeline.
     * @param {Contact_TimelineUpdateArgs} args - Arguments to update one Contact_Timeline.
     * @example
     * // Update one Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Contact_TimelineUpdateArgs>(args: SelectSubset<T, Contact_TimelineUpdateArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contact_Timelines.
     * @param {Contact_TimelineDeleteManyArgs} args - Arguments to filter Contact_Timelines to delete.
     * @example
     * // Delete a few Contact_Timelines
     * const { count } = await prisma.contact_Timeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Contact_TimelineDeleteManyArgs>(args?: SelectSubset<T, Contact_TimelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contact_Timelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contact_Timelines
     * const contact_Timeline = await prisma.contact_Timeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Contact_TimelineUpdateManyArgs>(args: SelectSubset<T, Contact_TimelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact_Timeline.
     * @param {Contact_TimelineUpsertArgs} args - Arguments to update or create a Contact_Timeline.
     * @example
     * // Update or create a Contact_Timeline
     * const contact_Timeline = await prisma.contact_Timeline.upsert({
     *   create: {
     *     // ... data to create a Contact_Timeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact_Timeline we want to update
     *   }
     * })
     */
    upsert<T extends Contact_TimelineUpsertArgs>(args: SelectSubset<T, Contact_TimelineUpsertArgs<ExtArgs>>): Prisma__Contact_TimelineClient<$Result.GetResult<Prisma.$Contact_TimelinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contact_Timelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineCountArgs} args - Arguments to filter Contact_Timelines to count.
     * @example
     * // Count the number of Contact_Timelines
     * const count = await prisma.contact_Timeline.count({
     *   where: {
     *     // ... the filter for the Contact_Timelines we want to count
     *   }
     * })
    **/
    count<T extends Contact_TimelineCountArgs>(
      args?: Subset<T, Contact_TimelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Contact_TimelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact_Timeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Contact_TimelineAggregateArgs>(args: Subset<T, Contact_TimelineAggregateArgs>): Prisma.PrismaPromise<GetContact_TimelineAggregateType<T>>

    /**
     * Group by Contact_Timeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Contact_TimelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Contact_TimelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Contact_TimelineGroupByArgs['orderBy'] }
        : { orderBy?: Contact_TimelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Contact_TimelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContact_TimelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact_Timeline model
   */
  readonly fields: Contact_TimelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact_Timeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Contact_TimelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact_Timeline model
   */ 
  interface Contact_TimelineFieldRefs {
    readonly id: FieldRef<"Contact_Timeline", 'Int'>
    readonly contact_id: FieldRef<"Contact_Timeline", 'Int'>
    readonly sub_campaign_id: FieldRef<"Contact_Timeline", 'Int'>
    readonly title: FieldRef<"Contact_Timeline", 'String'>
    readonly description: FieldRef<"Contact_Timeline", 'String'>
    readonly createdAt: FieldRef<"Contact_Timeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact_Timeline findUnique
   */
  export type Contact_TimelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Timeline to fetch.
     */
    where: Contact_TimelineWhereUniqueInput
  }

  /**
   * Contact_Timeline findUniqueOrThrow
   */
  export type Contact_TimelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Timeline to fetch.
     */
    where: Contact_TimelineWhereUniqueInput
  }

  /**
   * Contact_Timeline findFirst
   */
  export type Contact_TimelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Timeline to fetch.
     */
    where?: Contact_TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Timelines to fetch.
     */
    orderBy?: Contact_TimelineOrderByWithRelationInput | Contact_TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Timelines.
     */
    cursor?: Contact_TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Timelines.
     */
    distinct?: Contact_TimelineScalarFieldEnum | Contact_TimelineScalarFieldEnum[]
  }

  /**
   * Contact_Timeline findFirstOrThrow
   */
  export type Contact_TimelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Timeline to fetch.
     */
    where?: Contact_TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Timelines to fetch.
     */
    orderBy?: Contact_TimelineOrderByWithRelationInput | Contact_TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contact_Timelines.
     */
    cursor?: Contact_TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Timelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contact_Timelines.
     */
    distinct?: Contact_TimelineScalarFieldEnum | Contact_TimelineScalarFieldEnum[]
  }

  /**
   * Contact_Timeline findMany
   */
  export type Contact_TimelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter, which Contact_Timelines to fetch.
     */
    where?: Contact_TimelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contact_Timelines to fetch.
     */
    orderBy?: Contact_TimelineOrderByWithRelationInput | Contact_TimelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contact_Timelines.
     */
    cursor?: Contact_TimelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contact_Timelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contact_Timelines.
     */
    skip?: number
    distinct?: Contact_TimelineScalarFieldEnum | Contact_TimelineScalarFieldEnum[]
  }

  /**
   * Contact_Timeline create
   */
  export type Contact_TimelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * The data needed to create a Contact_Timeline.
     */
    data: XOR<Contact_TimelineCreateInput, Contact_TimelineUncheckedCreateInput>
  }

  /**
   * Contact_Timeline createMany
   */
  export type Contact_TimelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contact_Timelines.
     */
    data: Contact_TimelineCreateManyInput | Contact_TimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Timeline createManyAndReturn
   */
  export type Contact_TimelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contact_Timelines.
     */
    data: Contact_TimelineCreateManyInput | Contact_TimelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact_Timeline update
   */
  export type Contact_TimelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * The data needed to update a Contact_Timeline.
     */
    data: XOR<Contact_TimelineUpdateInput, Contact_TimelineUncheckedUpdateInput>
    /**
     * Choose, which Contact_Timeline to update.
     */
    where: Contact_TimelineWhereUniqueInput
  }

  /**
   * Contact_Timeline updateMany
   */
  export type Contact_TimelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contact_Timelines.
     */
    data: XOR<Contact_TimelineUpdateManyMutationInput, Contact_TimelineUncheckedUpdateManyInput>
    /**
     * Filter which Contact_Timelines to update
     */
    where?: Contact_TimelineWhereInput
  }

  /**
   * Contact_Timeline upsert
   */
  export type Contact_TimelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * The filter to search for the Contact_Timeline to update in case it exists.
     */
    where: Contact_TimelineWhereUniqueInput
    /**
     * In case the Contact_Timeline found by the `where` argument doesn't exist, create a new Contact_Timeline with this data.
     */
    create: XOR<Contact_TimelineCreateInput, Contact_TimelineUncheckedCreateInput>
    /**
     * In case the Contact_Timeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Contact_TimelineUpdateInput, Contact_TimelineUncheckedUpdateInput>
  }

  /**
   * Contact_Timeline delete
   */
  export type Contact_TimelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
    /**
     * Filter which Contact_Timeline to delete.
     */
    where: Contact_TimelineWhereUniqueInput
  }

  /**
   * Contact_Timeline deleteMany
   */
  export type Contact_TimelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact_Timelines to delete
     */
    where?: Contact_TimelineWhereInput
  }

  /**
   * Contact_Timeline without action
   */
  export type Contact_TimelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact_Timeline
     */
    select?: Contact_TimelineSelect<ExtArgs> | null
  }


  /**
   * Model Campaign_User
   */

  export type AggregateCampaign_User = {
    _count: Campaign_UserCountAggregateOutputType | null
    _avg: Campaign_UserAvgAggregateOutputType | null
    _sum: Campaign_UserSumAggregateOutputType | null
    _min: Campaign_UserMinAggregateOutputType | null
    _max: Campaign_UserMaxAggregateOutputType | null
  }

  export type Campaign_UserAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    sub_campaign_id: number | null
    client_id: number | null
  }

  export type Campaign_UserSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    sub_campaign_id: number | null
    client_id: number | null
  }

  export type Campaign_UserMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    sub_campaign_id: number | null
    client_id: number | null
    createdAt: Date | null
  }

  export type Campaign_UserMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    sub_campaign_id: number | null
    client_id: number | null
    createdAt: Date | null
  }

  export type Campaign_UserCountAggregateOutputType = {
    id: number
    user_id: number
    sub_campaign_id: number
    client_id: number
    createdAt: number
    _all: number
  }


  export type Campaign_UserAvgAggregateInputType = {
    id?: true
    user_id?: true
    sub_campaign_id?: true
    client_id?: true
  }

  export type Campaign_UserSumAggregateInputType = {
    id?: true
    user_id?: true
    sub_campaign_id?: true
    client_id?: true
  }

  export type Campaign_UserMinAggregateInputType = {
    id?: true
    user_id?: true
    sub_campaign_id?: true
    client_id?: true
    createdAt?: true
  }

  export type Campaign_UserMaxAggregateInputType = {
    id?: true
    user_id?: true
    sub_campaign_id?: true
    client_id?: true
    createdAt?: true
  }

  export type Campaign_UserCountAggregateInputType = {
    id?: true
    user_id?: true
    sub_campaign_id?: true
    client_id?: true
    createdAt?: true
    _all?: true
  }

  export type Campaign_UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign_User to aggregate.
     */
    where?: Campaign_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaign_Users to fetch.
     */
    orderBy?: Campaign_UserOrderByWithRelationInput | Campaign_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Campaign_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaign_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaign_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaign_Users
    **/
    _count?: true | Campaign_UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Campaign_UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Campaign_UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Campaign_UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Campaign_UserMaxAggregateInputType
  }

  export type GetCampaign_UserAggregateType<T extends Campaign_UserAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign_User]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign_User[P]>
      : GetScalarType<T[P], AggregateCampaign_User[P]>
  }




  export type Campaign_UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Campaign_UserWhereInput
    orderBy?: Campaign_UserOrderByWithAggregationInput | Campaign_UserOrderByWithAggregationInput[]
    by: Campaign_UserScalarFieldEnum[] | Campaign_UserScalarFieldEnum
    having?: Campaign_UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Campaign_UserCountAggregateInputType | true
    _avg?: Campaign_UserAvgAggregateInputType
    _sum?: Campaign_UserSumAggregateInputType
    _min?: Campaign_UserMinAggregateInputType
    _max?: Campaign_UserMaxAggregateInputType
  }

  export type Campaign_UserGroupByOutputType = {
    id: number
    user_id: number
    sub_campaign_id: number
    client_id: number
    createdAt: Date
    _count: Campaign_UserCountAggregateOutputType | null
    _avg: Campaign_UserAvgAggregateOutputType | null
    _sum: Campaign_UserSumAggregateOutputType | null
    _min: Campaign_UserMinAggregateOutputType | null
    _max: Campaign_UserMaxAggregateOutputType | null
  }

  type GetCampaign_UserGroupByPayload<T extends Campaign_UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Campaign_UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Campaign_UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Campaign_UserGroupByOutputType[P]>
            : GetScalarType<T[P], Campaign_UserGroupByOutputType[P]>
        }
      >
    >


  export type Campaign_UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    sub_campaign_id?: boolean
    client_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign_User"]>

  export type Campaign_UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    sub_campaign_id?: boolean
    client_id?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["campaign_User"]>

  export type Campaign_UserSelectScalar = {
    id?: boolean
    user_id?: boolean
    sub_campaign_id?: boolean
    client_id?: boolean
    createdAt?: boolean
  }


  export type $Campaign_UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign_User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      sub_campaign_id: number
      client_id: number
      createdAt: Date
    }, ExtArgs["result"]["campaign_User"]>
    composites: {}
  }

  type Campaign_UserGetPayload<S extends boolean | null | undefined | Campaign_UserDefaultArgs> = $Result.GetResult<Prisma.$Campaign_UserPayload, S>

  type Campaign_UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Campaign_UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Campaign_UserCountAggregateInputType | true
    }

  export interface Campaign_UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign_User'], meta: { name: 'Campaign_User' } }
    /**
     * Find zero or one Campaign_User that matches the filter.
     * @param {Campaign_UserFindUniqueArgs} args - Arguments to find a Campaign_User
     * @example
     * // Get one Campaign_User
     * const campaign_User = await prisma.campaign_User.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Campaign_UserFindUniqueArgs>(args: SelectSubset<T, Campaign_UserFindUniqueArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign_User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Campaign_UserFindUniqueOrThrowArgs} args - Arguments to find a Campaign_User
     * @example
     * // Get one Campaign_User
     * const campaign_User = await prisma.campaign_User.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Campaign_UserFindUniqueOrThrowArgs>(args: SelectSubset<T, Campaign_UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign_User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserFindFirstArgs} args - Arguments to find a Campaign_User
     * @example
     * // Get one Campaign_User
     * const campaign_User = await prisma.campaign_User.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Campaign_UserFindFirstArgs>(args?: SelectSubset<T, Campaign_UserFindFirstArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign_User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserFindFirstOrThrowArgs} args - Arguments to find a Campaign_User
     * @example
     * // Get one Campaign_User
     * const campaign_User = await prisma.campaign_User.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Campaign_UserFindFirstOrThrowArgs>(args?: SelectSubset<T, Campaign_UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaign_Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaign_Users
     * const campaign_Users = await prisma.campaign_User.findMany()
     * 
     * // Get first 10 Campaign_Users
     * const campaign_Users = await prisma.campaign_User.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaign_UserWithIdOnly = await prisma.campaign_User.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Campaign_UserFindManyArgs>(args?: SelectSubset<T, Campaign_UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign_User.
     * @param {Campaign_UserCreateArgs} args - Arguments to create a Campaign_User.
     * @example
     * // Create one Campaign_User
     * const Campaign_User = await prisma.campaign_User.create({
     *   data: {
     *     // ... data to create a Campaign_User
     *   }
     * })
     * 
     */
    create<T extends Campaign_UserCreateArgs>(args: SelectSubset<T, Campaign_UserCreateArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaign_Users.
     * @param {Campaign_UserCreateManyArgs} args - Arguments to create many Campaign_Users.
     * @example
     * // Create many Campaign_Users
     * const campaign_User = await prisma.campaign_User.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Campaign_UserCreateManyArgs>(args?: SelectSubset<T, Campaign_UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaign_Users and returns the data saved in the database.
     * @param {Campaign_UserCreateManyAndReturnArgs} args - Arguments to create many Campaign_Users.
     * @example
     * // Create many Campaign_Users
     * const campaign_User = await prisma.campaign_User.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaign_Users and only return the `id`
     * const campaign_UserWithIdOnly = await prisma.campaign_User.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Campaign_UserCreateManyAndReturnArgs>(args?: SelectSubset<T, Campaign_UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign_User.
     * @param {Campaign_UserDeleteArgs} args - Arguments to delete one Campaign_User.
     * @example
     * // Delete one Campaign_User
     * const Campaign_User = await prisma.campaign_User.delete({
     *   where: {
     *     // ... filter to delete one Campaign_User
     *   }
     * })
     * 
     */
    delete<T extends Campaign_UserDeleteArgs>(args: SelectSubset<T, Campaign_UserDeleteArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign_User.
     * @param {Campaign_UserUpdateArgs} args - Arguments to update one Campaign_User.
     * @example
     * // Update one Campaign_User
     * const campaign_User = await prisma.campaign_User.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Campaign_UserUpdateArgs>(args: SelectSubset<T, Campaign_UserUpdateArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaign_Users.
     * @param {Campaign_UserDeleteManyArgs} args - Arguments to filter Campaign_Users to delete.
     * @example
     * // Delete a few Campaign_Users
     * const { count } = await prisma.campaign_User.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Campaign_UserDeleteManyArgs>(args?: SelectSubset<T, Campaign_UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaign_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaign_Users
     * const campaign_User = await prisma.campaign_User.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Campaign_UserUpdateManyArgs>(args: SelectSubset<T, Campaign_UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign_User.
     * @param {Campaign_UserUpsertArgs} args - Arguments to update or create a Campaign_User.
     * @example
     * // Update or create a Campaign_User
     * const campaign_User = await prisma.campaign_User.upsert({
     *   create: {
     *     // ... data to create a Campaign_User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign_User we want to update
     *   }
     * })
     */
    upsert<T extends Campaign_UserUpsertArgs>(args: SelectSubset<T, Campaign_UserUpsertArgs<ExtArgs>>): Prisma__Campaign_UserClient<$Result.GetResult<Prisma.$Campaign_UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaign_Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserCountArgs} args - Arguments to filter Campaign_Users to count.
     * @example
     * // Count the number of Campaign_Users
     * const count = await prisma.campaign_User.count({
     *   where: {
     *     // ... the filter for the Campaign_Users we want to count
     *   }
     * })
    **/
    count<T extends Campaign_UserCountArgs>(
      args?: Subset<T, Campaign_UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Campaign_UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign_User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Campaign_UserAggregateArgs>(args: Subset<T, Campaign_UserAggregateArgs>): Prisma.PrismaPromise<GetCampaign_UserAggregateType<T>>

    /**
     * Group by Campaign_User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Campaign_UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Campaign_UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Campaign_UserGroupByArgs['orderBy'] }
        : { orderBy?: Campaign_UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Campaign_UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaign_UserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign_User model
   */
  readonly fields: Campaign_UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign_User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Campaign_UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign_User model
   */ 
  interface Campaign_UserFieldRefs {
    readonly id: FieldRef<"Campaign_User", 'Int'>
    readonly user_id: FieldRef<"Campaign_User", 'Int'>
    readonly sub_campaign_id: FieldRef<"Campaign_User", 'Int'>
    readonly client_id: FieldRef<"Campaign_User", 'Int'>
    readonly createdAt: FieldRef<"Campaign_User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign_User findUnique
   */
  export type Campaign_UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter, which Campaign_User to fetch.
     */
    where: Campaign_UserWhereUniqueInput
  }

  /**
   * Campaign_User findUniqueOrThrow
   */
  export type Campaign_UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter, which Campaign_User to fetch.
     */
    where: Campaign_UserWhereUniqueInput
  }

  /**
   * Campaign_User findFirst
   */
  export type Campaign_UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter, which Campaign_User to fetch.
     */
    where?: Campaign_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaign_Users to fetch.
     */
    orderBy?: Campaign_UserOrderByWithRelationInput | Campaign_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaign_Users.
     */
    cursor?: Campaign_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaign_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaign_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaign_Users.
     */
    distinct?: Campaign_UserScalarFieldEnum | Campaign_UserScalarFieldEnum[]
  }

  /**
   * Campaign_User findFirstOrThrow
   */
  export type Campaign_UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter, which Campaign_User to fetch.
     */
    where?: Campaign_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaign_Users to fetch.
     */
    orderBy?: Campaign_UserOrderByWithRelationInput | Campaign_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaign_Users.
     */
    cursor?: Campaign_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaign_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaign_Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaign_Users.
     */
    distinct?: Campaign_UserScalarFieldEnum | Campaign_UserScalarFieldEnum[]
  }

  /**
   * Campaign_User findMany
   */
  export type Campaign_UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter, which Campaign_Users to fetch.
     */
    where?: Campaign_UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaign_Users to fetch.
     */
    orderBy?: Campaign_UserOrderByWithRelationInput | Campaign_UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaign_Users.
     */
    cursor?: Campaign_UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaign_Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaign_Users.
     */
    skip?: number
    distinct?: Campaign_UserScalarFieldEnum | Campaign_UserScalarFieldEnum[]
  }

  /**
   * Campaign_User create
   */
  export type Campaign_UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * The data needed to create a Campaign_User.
     */
    data: XOR<Campaign_UserCreateInput, Campaign_UserUncheckedCreateInput>
  }

  /**
   * Campaign_User createMany
   */
  export type Campaign_UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaign_Users.
     */
    data: Campaign_UserCreateManyInput | Campaign_UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign_User createManyAndReturn
   */
  export type Campaign_UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaign_Users.
     */
    data: Campaign_UserCreateManyInput | Campaign_UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign_User update
   */
  export type Campaign_UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * The data needed to update a Campaign_User.
     */
    data: XOR<Campaign_UserUpdateInput, Campaign_UserUncheckedUpdateInput>
    /**
     * Choose, which Campaign_User to update.
     */
    where: Campaign_UserWhereUniqueInput
  }

  /**
   * Campaign_User updateMany
   */
  export type Campaign_UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaign_Users.
     */
    data: XOR<Campaign_UserUpdateManyMutationInput, Campaign_UserUncheckedUpdateManyInput>
    /**
     * Filter which Campaign_Users to update
     */
    where?: Campaign_UserWhereInput
  }

  /**
   * Campaign_User upsert
   */
  export type Campaign_UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * The filter to search for the Campaign_User to update in case it exists.
     */
    where: Campaign_UserWhereUniqueInput
    /**
     * In case the Campaign_User found by the `where` argument doesn't exist, create a new Campaign_User with this data.
     */
    create: XOR<Campaign_UserCreateInput, Campaign_UserUncheckedCreateInput>
    /**
     * In case the Campaign_User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Campaign_UserUpdateInput, Campaign_UserUncheckedUpdateInput>
  }

  /**
   * Campaign_User delete
   */
  export type Campaign_UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
    /**
     * Filter which Campaign_User to delete.
     */
    where: Campaign_UserWhereUniqueInput
  }

  /**
   * Campaign_User deleteMany
   */
  export type Campaign_UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign_Users to delete
     */
    where?: Campaign_UserWhereInput
  }

  /**
   * Campaign_User without action
   */
  export type Campaign_UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign_User
     */
    select?: Campaign_UserSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    title: 'title',
    role: 'role',
    password: 'password',
    client_id: 'client_id',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    address: 'address',
    industry: 'industry',
    phone_number: 'phone_number',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    client_id: 'client_id',
    status: 'status',
    created_by: 'created_by',
    createdAt: 'createdAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const Sub_CampaignScalarFieldEnum: {
    id: 'id',
    campaign_id: 'campaign_id',
    name: 'name',
    owner: 'owner',
    manager: 'manager',
    status: 'status',
    client_id: 'client_id',
    created_by: 'created_by',
    createdAt: 'createdAt'
  };

  export type Sub_CampaignScalarFieldEnum = (typeof Sub_CampaignScalarFieldEnum)[keyof typeof Sub_CampaignScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    sub_campaign_id: 'sub_campaign_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    country: 'country',
    address: 'address',
    tag: 'tag',
    level_priority: 'level_priority',
    source: 'source',
    status: 'status',
    result_negotiation: 'result_negotiation',
    createdAt: 'createdAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const Contact_ParentScalarFieldEnum: {
    id: 'id',
    parent_contact_id: 'parent_contact_id',
    contact_id: 'contact_id',
    createdAt: 'createdAt'
  };

  export type Contact_ParentScalarFieldEnum = (typeof Contact_ParentScalarFieldEnum)[keyof typeof Contact_ParentScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    contact_id: 'contact_id',
    tag: 'tag',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const Contact_NoteScalarFieldEnum: {
    id: 'id',
    sub_campaign_id: 'sub_campaign_id',
    contact_id: 'contact_id',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type Contact_NoteScalarFieldEnum = (typeof Contact_NoteScalarFieldEnum)[keyof typeof Contact_NoteScalarFieldEnum]


  export const Contact_ActivityScalarFieldEnum: {
    id: 'id',
    contact_id: 'contact_id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type Contact_ActivityScalarFieldEnum = (typeof Contact_ActivityScalarFieldEnum)[keyof typeof Contact_ActivityScalarFieldEnum]


  export const Contact_BantScalarFieldEnum: {
    id: 'id',
    contact_id: 'contact_id',
    lead_type: 'lead_type',
    lead_owner: 'lead_owner',
    budget: 'budget',
    authority: 'authority',
    need: 'need',
    time: 'time',
    spesification_project: 'spesification_project',
    next_step: 'next_step',
    createdAt: 'createdAt'
  };

  export type Contact_BantScalarFieldEnum = (typeof Contact_BantScalarFieldEnum)[keyof typeof Contact_BantScalarFieldEnum]


  export const Contact_TimelineScalarFieldEnum: {
    id: 'id',
    contact_id: 'contact_id',
    sub_campaign_id: 'sub_campaign_id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type Contact_TimelineScalarFieldEnum = (typeof Contact_TimelineScalarFieldEnum)[keyof typeof Contact_TimelineScalarFieldEnum]


  export const Campaign_UserScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    sub_campaign_id: 'sub_campaign_id',
    client_id: 'client_id',
    createdAt: 'createdAt'
  };

  export type Campaign_UserScalarFieldEnum = (typeof Campaign_UserScalarFieldEnum)[keyof typeof Campaign_UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    title?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    client_id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    role?: SortOrder
    password?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    title?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    client_id?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    role?: SortOrder
    password?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    title?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    client_id?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    name?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    address?: StringFilter<"Client"> | string
    industry?: StringFilter<"Client"> | string
    phone_number?: StringFilter<"Client"> | string
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    industry?: SortOrder
    phone_number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    address?: StringFilter<"Client"> | string
    industry?: StringFilter<"Client"> | string
    phone_number?: StringFilter<"Client"> | string
    status?: StringFilter<"Client"> | string
    createdAt?: DateTimeFilter<"Client"> | Date | string
  }, "id" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    industry?: SortOrder
    phone_number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    name?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    address?: StringWithAggregatesFilter<"Client"> | string
    industry?: StringWithAggregatesFilter<"Client"> | string
    phone_number?: StringWithAggregatesFilter<"Client"> | string
    status?: StringWithAggregatesFilter<"Client"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: IntFilter<"Campaign"> | number
    name?: StringFilter<"Campaign"> | string
    client_id?: IntFilter<"Campaign"> | number
    status?: StringFilter<"Campaign"> | string
    created_by?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    client_id?: IntFilter<"Campaign"> | number
    status?: StringFilter<"Campaign"> | string
    created_by?: IntFilter<"Campaign"> | number
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campaign"> | number
    name?: StringWithAggregatesFilter<"Campaign"> | string
    client_id?: IntWithAggregatesFilter<"Campaign"> | number
    status?: StringWithAggregatesFilter<"Campaign"> | string
    created_by?: IntWithAggregatesFilter<"Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type Sub_CampaignWhereInput = {
    AND?: Sub_CampaignWhereInput | Sub_CampaignWhereInput[]
    OR?: Sub_CampaignWhereInput[]
    NOT?: Sub_CampaignWhereInput | Sub_CampaignWhereInput[]
    id?: IntFilter<"Sub_Campaign"> | number
    campaign_id?: IntFilter<"Sub_Campaign"> | number
    name?: StringFilter<"Sub_Campaign"> | string
    owner?: IntFilter<"Sub_Campaign"> | number
    manager?: IntFilter<"Sub_Campaign"> | number
    status?: StringFilter<"Sub_Campaign"> | string
    client_id?: IntFilter<"Sub_Campaign"> | number
    created_by?: IntFilter<"Sub_Campaign"> | number
    createdAt?: DateTimeFilter<"Sub_Campaign"> | Date | string
  }

  export type Sub_CampaignOrderByWithRelationInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type Sub_CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Sub_CampaignWhereInput | Sub_CampaignWhereInput[]
    OR?: Sub_CampaignWhereInput[]
    NOT?: Sub_CampaignWhereInput | Sub_CampaignWhereInput[]
    campaign_id?: IntFilter<"Sub_Campaign"> | number
    name?: StringFilter<"Sub_Campaign"> | string
    owner?: IntFilter<"Sub_Campaign"> | number
    manager?: IntFilter<"Sub_Campaign"> | number
    status?: StringFilter<"Sub_Campaign"> | string
    client_id?: IntFilter<"Sub_Campaign"> | number
    created_by?: IntFilter<"Sub_Campaign"> | number
    createdAt?: DateTimeFilter<"Sub_Campaign"> | Date | string
  }, "id">

  export type Sub_CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
    _count?: Sub_CampaignCountOrderByAggregateInput
    _avg?: Sub_CampaignAvgOrderByAggregateInput
    _max?: Sub_CampaignMaxOrderByAggregateInput
    _min?: Sub_CampaignMinOrderByAggregateInput
    _sum?: Sub_CampaignSumOrderByAggregateInput
  }

  export type Sub_CampaignScalarWhereWithAggregatesInput = {
    AND?: Sub_CampaignScalarWhereWithAggregatesInput | Sub_CampaignScalarWhereWithAggregatesInput[]
    OR?: Sub_CampaignScalarWhereWithAggregatesInput[]
    NOT?: Sub_CampaignScalarWhereWithAggregatesInput | Sub_CampaignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    campaign_id?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    name?: StringWithAggregatesFilter<"Sub_Campaign"> | string
    owner?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    manager?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    status?: StringWithAggregatesFilter<"Sub_Campaign"> | string
    client_id?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    created_by?: IntWithAggregatesFilter<"Sub_Campaign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sub_Campaign"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    sub_campaign_id?: IntFilter<"Contact"> | number
    first_name?: StringFilter<"Contact"> | string
    last_name?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    country?: StringFilter<"Contact"> | string
    address?: StringFilter<"Contact"> | string
    tag?: StringFilter<"Contact"> | string
    level_priority?: StringFilter<"Contact"> | string
    source?: StringFilter<"Contact"> | string
    status?: StringFilter<"Contact"> | string
    result_negotiation?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    address?: SortOrder
    tag?: SortOrder
    level_priority?: SortOrder
    source?: SortOrder
    status?: SortOrder
    result_negotiation?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    sub_campaign_id?: IntFilter<"Contact"> | number
    first_name?: StringFilter<"Contact"> | string
    last_name?: StringFilter<"Contact"> | string
    country?: StringFilter<"Contact"> | string
    address?: StringFilter<"Contact"> | string
    tag?: StringFilter<"Contact"> | string
    level_priority?: StringFilter<"Contact"> | string
    source?: StringFilter<"Contact"> | string
    status?: StringFilter<"Contact"> | string
    result_negotiation?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
  }, "id" | "email">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    address?: SortOrder
    tag?: SortOrder
    level_priority?: SortOrder
    source?: SortOrder
    status?: SortOrder
    result_negotiation?: SortOrder
    createdAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    sub_campaign_id?: IntWithAggregatesFilter<"Contact"> | number
    first_name?: StringWithAggregatesFilter<"Contact"> | string
    last_name?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    country?: StringWithAggregatesFilter<"Contact"> | string
    address?: StringWithAggregatesFilter<"Contact"> | string
    tag?: StringWithAggregatesFilter<"Contact"> | string
    level_priority?: StringWithAggregatesFilter<"Contact"> | string
    source?: StringWithAggregatesFilter<"Contact"> | string
    status?: StringWithAggregatesFilter<"Contact"> | string
    result_negotiation?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type Contact_ParentWhereInput = {
    AND?: Contact_ParentWhereInput | Contact_ParentWhereInput[]
    OR?: Contact_ParentWhereInput[]
    NOT?: Contact_ParentWhereInput | Contact_ParentWhereInput[]
    id?: IntFilter<"Contact_Parent"> | number
    parent_contact_id?: IntFilter<"Contact_Parent"> | number
    contact_id?: IntFilter<"Contact_Parent"> | number
    createdAt?: DateTimeFilter<"Contact_Parent"> | Date | string
  }

  export type Contact_ParentOrderByWithRelationInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Contact_ParentWhereInput | Contact_ParentWhereInput[]
    OR?: Contact_ParentWhereInput[]
    NOT?: Contact_ParentWhereInput | Contact_ParentWhereInput[]
    parent_contact_id?: IntFilter<"Contact_Parent"> | number
    contact_id?: IntFilter<"Contact_Parent"> | number
    createdAt?: DateTimeFilter<"Contact_Parent"> | Date | string
  }, "id">

  export type Contact_ParentOrderByWithAggregationInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
    createdAt?: SortOrder
    _count?: Contact_ParentCountOrderByAggregateInput
    _avg?: Contact_ParentAvgOrderByAggregateInput
    _max?: Contact_ParentMaxOrderByAggregateInput
    _min?: Contact_ParentMinOrderByAggregateInput
    _sum?: Contact_ParentSumOrderByAggregateInput
  }

  export type Contact_ParentScalarWhereWithAggregatesInput = {
    AND?: Contact_ParentScalarWhereWithAggregatesInput | Contact_ParentScalarWhereWithAggregatesInput[]
    OR?: Contact_ParentScalarWhereWithAggregatesInput[]
    NOT?: Contact_ParentScalarWhereWithAggregatesInput | Contact_ParentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact_Parent"> | number
    parent_contact_id?: IntWithAggregatesFilter<"Contact_Parent"> | number
    contact_id?: IntWithAggregatesFilter<"Contact_Parent"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Contact_Parent"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    contact_id?: IntFilter<"Customer"> | number
    tag?: StringFilter<"Customer"> | string
    note?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    tag?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    contact_id?: IntFilter<"Customer"> | number
    tag?: StringFilter<"Customer"> | string
    note?: StringFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    tag?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    contact_id?: IntWithAggregatesFilter<"Customer"> | number
    tag?: StringWithAggregatesFilter<"Customer"> | string
    note?: StringWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type Contact_NoteWhereInput = {
    AND?: Contact_NoteWhereInput | Contact_NoteWhereInput[]
    OR?: Contact_NoteWhereInput[]
    NOT?: Contact_NoteWhereInput | Contact_NoteWhereInput[]
    id?: IntFilter<"Contact_Note"> | number
    sub_campaign_id?: IntFilter<"Contact_Note"> | number
    contact_id?: IntFilter<"Contact_Note"> | number
    note?: StringFilter<"Contact_Note"> | string
    createdAt?: DateTimeFilter<"Contact_Note"> | Date | string
  }

  export type Contact_NoteOrderByWithRelationInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Contact_NoteWhereInput | Contact_NoteWhereInput[]
    OR?: Contact_NoteWhereInput[]
    NOT?: Contact_NoteWhereInput | Contact_NoteWhereInput[]
    sub_campaign_id?: IntFilter<"Contact_Note"> | number
    contact_id?: IntFilter<"Contact_Note"> | number
    note?: StringFilter<"Contact_Note"> | string
    createdAt?: DateTimeFilter<"Contact_Note"> | Date | string
  }, "id">

  export type Contact_NoteOrderByWithAggregationInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    _count?: Contact_NoteCountOrderByAggregateInput
    _avg?: Contact_NoteAvgOrderByAggregateInput
    _max?: Contact_NoteMaxOrderByAggregateInput
    _min?: Contact_NoteMinOrderByAggregateInput
    _sum?: Contact_NoteSumOrderByAggregateInput
  }

  export type Contact_NoteScalarWhereWithAggregatesInput = {
    AND?: Contact_NoteScalarWhereWithAggregatesInput | Contact_NoteScalarWhereWithAggregatesInput[]
    OR?: Contact_NoteScalarWhereWithAggregatesInput[]
    NOT?: Contact_NoteScalarWhereWithAggregatesInput | Contact_NoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact_Note"> | number
    sub_campaign_id?: IntWithAggregatesFilter<"Contact_Note"> | number
    contact_id?: IntWithAggregatesFilter<"Contact_Note"> | number
    note?: StringWithAggregatesFilter<"Contact_Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact_Note"> | Date | string
  }

  export type Contact_ActivityWhereInput = {
    AND?: Contact_ActivityWhereInput | Contact_ActivityWhereInput[]
    OR?: Contact_ActivityWhereInput[]
    NOT?: Contact_ActivityWhereInput | Contact_ActivityWhereInput[]
    id?: IntFilter<"Contact_Activity"> | number
    contact_id?: IntFilter<"Contact_Activity"> | number
    title?: StringFilter<"Contact_Activity"> | string
    description?: StringFilter<"Contact_Activity"> | string
    createdAt?: DateTimeFilter<"Contact_Activity"> | Date | string
  }

  export type Contact_ActivityOrderByWithRelationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Contact_ActivityWhereInput | Contact_ActivityWhereInput[]
    OR?: Contact_ActivityWhereInput[]
    NOT?: Contact_ActivityWhereInput | Contact_ActivityWhereInput[]
    contact_id?: IntFilter<"Contact_Activity"> | number
    title?: StringFilter<"Contact_Activity"> | string
    description?: StringFilter<"Contact_Activity"> | string
    createdAt?: DateTimeFilter<"Contact_Activity"> | Date | string
  }, "id">

  export type Contact_ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: Contact_ActivityCountOrderByAggregateInput
    _avg?: Contact_ActivityAvgOrderByAggregateInput
    _max?: Contact_ActivityMaxOrderByAggregateInput
    _min?: Contact_ActivityMinOrderByAggregateInput
    _sum?: Contact_ActivitySumOrderByAggregateInput
  }

  export type Contact_ActivityScalarWhereWithAggregatesInput = {
    AND?: Contact_ActivityScalarWhereWithAggregatesInput | Contact_ActivityScalarWhereWithAggregatesInput[]
    OR?: Contact_ActivityScalarWhereWithAggregatesInput[]
    NOT?: Contact_ActivityScalarWhereWithAggregatesInput | Contact_ActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact_Activity"> | number
    contact_id?: IntWithAggregatesFilter<"Contact_Activity"> | number
    title?: StringWithAggregatesFilter<"Contact_Activity"> | string
    description?: StringWithAggregatesFilter<"Contact_Activity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact_Activity"> | Date | string
  }

  export type Contact_BantWhereInput = {
    AND?: Contact_BantWhereInput | Contact_BantWhereInput[]
    OR?: Contact_BantWhereInput[]
    NOT?: Contact_BantWhereInput | Contact_BantWhereInput[]
    id?: IntFilter<"Contact_Bant"> | number
    contact_id?: IntFilter<"Contact_Bant"> | number
    lead_type?: IntFilter<"Contact_Bant"> | number
    lead_owner?: IntFilter<"Contact_Bant"> | number
    budget?: StringFilter<"Contact_Bant"> | string
    authority?: StringFilter<"Contact_Bant"> | string
    need?: StringFilter<"Contact_Bant"> | string
    time?: StringFilter<"Contact_Bant"> | string
    spesification_project?: StringFilter<"Contact_Bant"> | string
    next_step?: StringFilter<"Contact_Bant"> | string
    createdAt?: DateTimeFilter<"Contact_Bant"> | Date | string
  }

  export type Contact_BantOrderByWithRelationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
    budget?: SortOrder
    authority?: SortOrder
    need?: SortOrder
    time?: SortOrder
    spesification_project?: SortOrder
    next_step?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_BantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Contact_BantWhereInput | Contact_BantWhereInput[]
    OR?: Contact_BantWhereInput[]
    NOT?: Contact_BantWhereInput | Contact_BantWhereInput[]
    contact_id?: IntFilter<"Contact_Bant"> | number
    lead_type?: IntFilter<"Contact_Bant"> | number
    lead_owner?: IntFilter<"Contact_Bant"> | number
    budget?: StringFilter<"Contact_Bant"> | string
    authority?: StringFilter<"Contact_Bant"> | string
    need?: StringFilter<"Contact_Bant"> | string
    time?: StringFilter<"Contact_Bant"> | string
    spesification_project?: StringFilter<"Contact_Bant"> | string
    next_step?: StringFilter<"Contact_Bant"> | string
    createdAt?: DateTimeFilter<"Contact_Bant"> | Date | string
  }, "id">

  export type Contact_BantOrderByWithAggregationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
    budget?: SortOrder
    authority?: SortOrder
    need?: SortOrder
    time?: SortOrder
    spesification_project?: SortOrder
    next_step?: SortOrder
    createdAt?: SortOrder
    _count?: Contact_BantCountOrderByAggregateInput
    _avg?: Contact_BantAvgOrderByAggregateInput
    _max?: Contact_BantMaxOrderByAggregateInput
    _min?: Contact_BantMinOrderByAggregateInput
    _sum?: Contact_BantSumOrderByAggregateInput
  }

  export type Contact_BantScalarWhereWithAggregatesInput = {
    AND?: Contact_BantScalarWhereWithAggregatesInput | Contact_BantScalarWhereWithAggregatesInput[]
    OR?: Contact_BantScalarWhereWithAggregatesInput[]
    NOT?: Contact_BantScalarWhereWithAggregatesInput | Contact_BantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact_Bant"> | number
    contact_id?: IntWithAggregatesFilter<"Contact_Bant"> | number
    lead_type?: IntWithAggregatesFilter<"Contact_Bant"> | number
    lead_owner?: IntWithAggregatesFilter<"Contact_Bant"> | number
    budget?: StringWithAggregatesFilter<"Contact_Bant"> | string
    authority?: StringWithAggregatesFilter<"Contact_Bant"> | string
    need?: StringWithAggregatesFilter<"Contact_Bant"> | string
    time?: StringWithAggregatesFilter<"Contact_Bant"> | string
    spesification_project?: StringWithAggregatesFilter<"Contact_Bant"> | string
    next_step?: StringWithAggregatesFilter<"Contact_Bant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact_Bant"> | Date | string
  }

  export type Contact_TimelineWhereInput = {
    AND?: Contact_TimelineWhereInput | Contact_TimelineWhereInput[]
    OR?: Contact_TimelineWhereInput[]
    NOT?: Contact_TimelineWhereInput | Contact_TimelineWhereInput[]
    id?: IntFilter<"Contact_Timeline"> | number
    contact_id?: IntFilter<"Contact_Timeline"> | number
    sub_campaign_id?: IntFilter<"Contact_Timeline"> | number
    title?: StringFilter<"Contact_Timeline"> | string
    description?: StringFilter<"Contact_Timeline"> | string
    createdAt?: DateTimeFilter<"Contact_Timeline"> | Date | string
  }

  export type Contact_TimelineOrderByWithRelationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_TimelineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Contact_TimelineWhereInput | Contact_TimelineWhereInput[]
    OR?: Contact_TimelineWhereInput[]
    NOT?: Contact_TimelineWhereInput | Contact_TimelineWhereInput[]
    contact_id?: IntFilter<"Contact_Timeline"> | number
    sub_campaign_id?: IntFilter<"Contact_Timeline"> | number
    title?: StringFilter<"Contact_Timeline"> | string
    description?: StringFilter<"Contact_Timeline"> | string
    createdAt?: DateTimeFilter<"Contact_Timeline"> | Date | string
  }, "id">

  export type Contact_TimelineOrderByWithAggregationInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: Contact_TimelineCountOrderByAggregateInput
    _avg?: Contact_TimelineAvgOrderByAggregateInput
    _max?: Contact_TimelineMaxOrderByAggregateInput
    _min?: Contact_TimelineMinOrderByAggregateInput
    _sum?: Contact_TimelineSumOrderByAggregateInput
  }

  export type Contact_TimelineScalarWhereWithAggregatesInput = {
    AND?: Contact_TimelineScalarWhereWithAggregatesInput | Contact_TimelineScalarWhereWithAggregatesInput[]
    OR?: Contact_TimelineScalarWhereWithAggregatesInput[]
    NOT?: Contact_TimelineScalarWhereWithAggregatesInput | Contact_TimelineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact_Timeline"> | number
    contact_id?: IntWithAggregatesFilter<"Contact_Timeline"> | number
    sub_campaign_id?: IntWithAggregatesFilter<"Contact_Timeline"> | number
    title?: StringWithAggregatesFilter<"Contact_Timeline"> | string
    description?: StringWithAggregatesFilter<"Contact_Timeline"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact_Timeline"> | Date | string
  }

  export type Campaign_UserWhereInput = {
    AND?: Campaign_UserWhereInput | Campaign_UserWhereInput[]
    OR?: Campaign_UserWhereInput[]
    NOT?: Campaign_UserWhereInput | Campaign_UserWhereInput[]
    id?: IntFilter<"Campaign_User"> | number
    user_id?: IntFilter<"Campaign_User"> | number
    sub_campaign_id?: IntFilter<"Campaign_User"> | number
    client_id?: IntFilter<"Campaign_User"> | number
    createdAt?: DateTimeFilter<"Campaign_User"> | Date | string
  }

  export type Campaign_UserOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Campaign_UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Campaign_UserWhereInput | Campaign_UserWhereInput[]
    OR?: Campaign_UserWhereInput[]
    NOT?: Campaign_UserWhereInput | Campaign_UserWhereInput[]
    user_id?: IntFilter<"Campaign_User"> | number
    sub_campaign_id?: IntFilter<"Campaign_User"> | number
    client_id?: IntFilter<"Campaign_User"> | number
    createdAt?: DateTimeFilter<"Campaign_User"> | Date | string
  }, "id">

  export type Campaign_UserOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
    _count?: Campaign_UserCountOrderByAggregateInput
    _avg?: Campaign_UserAvgOrderByAggregateInput
    _max?: Campaign_UserMaxOrderByAggregateInput
    _min?: Campaign_UserMinOrderByAggregateInput
    _sum?: Campaign_UserSumOrderByAggregateInput
  }

  export type Campaign_UserScalarWhereWithAggregatesInput = {
    AND?: Campaign_UserScalarWhereWithAggregatesInput | Campaign_UserScalarWhereWithAggregatesInput[]
    OR?: Campaign_UserScalarWhereWithAggregatesInput[]
    NOT?: Campaign_UserScalarWhereWithAggregatesInput | Campaign_UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campaign_User"> | number
    user_id?: IntWithAggregatesFilter<"Campaign_User"> | number
    sub_campaign_id?: IntWithAggregatesFilter<"Campaign_User"> | number
    client_id?: IntWithAggregatesFilter<"Campaign_User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Campaign_User"> | Date | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    title: string
    role: string
    password: string
    client_id: number
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    title: string
    role: string
    password: string
    client_id: number
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    name: string
    email: string
    title: string
    role: string
    password: string
    client_id: number
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    name: string
    email: string
    address: string
    industry: string
    phone_number: string
    status: string
    createdAt?: Date | string
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    address: string
    industry: string
    phone_number: string
    status: string
    createdAt?: Date | string
  }

  export type ClientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyInput = {
    id?: number
    name: string
    email: string
    address: string
    industry: string
    phone_number: string
    status: string
    createdAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    industry?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    name: string
    client_id: number
    status: string
    created_by: number
    createdAt?: Date | string
  }

  export type CampaignUncheckedCreateInput = {
    id?: number
    name: string
    client_id: number
    status: string
    created_by: number
    createdAt?: Date | string
  }

  export type CampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyInput = {
    id?: number
    name: string
    client_id: number
    status: string
    created_by: number
    createdAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Sub_CampaignCreateInput = {
    campaign_id: number
    name: string
    owner: number
    manager: number
    status: string
    client_id: number
    created_by: number
    createdAt?: Date | string
  }

  export type Sub_CampaignUncheckedCreateInput = {
    id?: number
    campaign_id: number
    name: string
    owner: number
    manager: number
    status: string
    client_id: number
    created_by: number
    createdAt?: Date | string
  }

  export type Sub_CampaignUpdateInput = {
    campaign_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner?: IntFieldUpdateOperationsInput | number
    manager?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Sub_CampaignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaign_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner?: IntFieldUpdateOperationsInput | number
    manager?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Sub_CampaignCreateManyInput = {
    id?: number
    campaign_id: number
    name: string
    owner: number
    manager: number
    status: string
    client_id: number
    created_by: number
    createdAt?: Date | string
  }

  export type Sub_CampaignUpdateManyMutationInput = {
    campaign_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner?: IntFieldUpdateOperationsInput | number
    manager?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Sub_CampaignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaign_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    owner?: IntFieldUpdateOperationsInput | number
    manager?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    created_by?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    sub_campaign_id: number
    first_name: string
    last_name: string
    email: string
    country: string
    address: string
    tag: string
    level_priority: string
    source: string
    status: string
    result_negotiation: string
    createdAt?: Date | string
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    sub_campaign_id: number
    first_name: string
    last_name: string
    email: string
    country: string
    address: string
    tag: string
    level_priority: string
    source: string
    status: string
    result_negotiation: string
    createdAt?: Date | string
  }

  export type ContactUpdateInput = {
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    level_priority?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result_negotiation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    level_priority?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result_negotiation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: number
    sub_campaign_id: number
    first_name: string
    last_name: string
    email: string
    country: string
    address: string
    tag: string
    level_priority: string
    source: string
    status: string
    result_negotiation: string
    createdAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    level_priority?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result_negotiation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    level_priority?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result_negotiation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ParentCreateInput = {
    parent_contact_id: number
    contact_id: number
    createdAt?: Date | string
  }

  export type Contact_ParentUncheckedCreateInput = {
    id?: number
    parent_contact_id: number
    contact_id: number
    createdAt?: Date | string
  }

  export type Contact_ParentUpdateInput = {
    parent_contact_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ParentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_contact_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ParentCreateManyInput = {
    id?: number
    parent_contact_id: number
    contact_id: number
    createdAt?: Date | string
  }

  export type Contact_ParentUpdateManyMutationInput = {
    parent_contact_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ParentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    parent_contact_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    contact_id: number
    tag: string
    note: string
    createdAt?: Date | string
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    contact_id: number
    tag: string
    note: string
    createdAt?: Date | string
  }

  export type CustomerUpdateInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyInput = {
    id?: number
    contact_id: number
    tag: string
    note: string
    createdAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    tag?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_NoteCreateInput = {
    sub_campaign_id: number
    contact_id: number
    note: string
    createdAt?: Date | string
  }

  export type Contact_NoteUncheckedCreateInput = {
    id?: number
    sub_campaign_id: number
    contact_id: number
    note: string
    createdAt?: Date | string
  }

  export type Contact_NoteUpdateInput = {
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_NoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_NoteCreateManyInput = {
    id?: number
    sub_campaign_id: number
    contact_id: number
    note: string
    createdAt?: Date | string
  }

  export type Contact_NoteUpdateManyMutationInput = {
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_NoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ActivityCreateInput = {
    contact_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_ActivityUncheckedCreateInput = {
    id?: number
    contact_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_ActivityUpdateInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ActivityCreateManyInput = {
    id?: number
    contact_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_ActivityUpdateManyMutationInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_ActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_BantCreateInput = {
    contact_id: number
    lead_type: number
    lead_owner: number
    budget: string
    authority: string
    need: string
    time: string
    spesification_project: string
    next_step: string
    createdAt?: Date | string
  }

  export type Contact_BantUncheckedCreateInput = {
    id?: number
    contact_id: number
    lead_type: number
    lead_owner: number
    budget: string
    authority: string
    need: string
    time: string
    spesification_project: string
    next_step: string
    createdAt?: Date | string
  }

  export type Contact_BantUpdateInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    lead_type?: IntFieldUpdateOperationsInput | number
    lead_owner?: IntFieldUpdateOperationsInput | number
    budget?: StringFieldUpdateOperationsInput | string
    authority?: StringFieldUpdateOperationsInput | string
    need?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    spesification_project?: StringFieldUpdateOperationsInput | string
    next_step?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_BantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    lead_type?: IntFieldUpdateOperationsInput | number
    lead_owner?: IntFieldUpdateOperationsInput | number
    budget?: StringFieldUpdateOperationsInput | string
    authority?: StringFieldUpdateOperationsInput | string
    need?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    spesification_project?: StringFieldUpdateOperationsInput | string
    next_step?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_BantCreateManyInput = {
    id?: number
    contact_id: number
    lead_type: number
    lead_owner: number
    budget: string
    authority: string
    need: string
    time: string
    spesification_project: string
    next_step: string
    createdAt?: Date | string
  }

  export type Contact_BantUpdateManyMutationInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    lead_type?: IntFieldUpdateOperationsInput | number
    lead_owner?: IntFieldUpdateOperationsInput | number
    budget?: StringFieldUpdateOperationsInput | string
    authority?: StringFieldUpdateOperationsInput | string
    need?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    spesification_project?: StringFieldUpdateOperationsInput | string
    next_step?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_BantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    lead_type?: IntFieldUpdateOperationsInput | number
    lead_owner?: IntFieldUpdateOperationsInput | number
    budget?: StringFieldUpdateOperationsInput | string
    authority?: StringFieldUpdateOperationsInput | string
    need?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    spesification_project?: StringFieldUpdateOperationsInput | string
    next_step?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_TimelineCreateInput = {
    contact_id: number
    sub_campaign_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_TimelineUncheckedCreateInput = {
    id?: number
    contact_id: number
    sub_campaign_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_TimelineUpdateInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_TimelineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_TimelineCreateManyInput = {
    id?: number
    contact_id: number
    sub_campaign_id: number
    title: string
    description: string
    createdAt?: Date | string
  }

  export type Contact_TimelineUpdateManyMutationInput = {
    contact_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Contact_TimelineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contact_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Campaign_UserCreateInput = {
    user_id: number
    sub_campaign_id: number
    client_id: number
    createdAt?: Date | string
  }

  export type Campaign_UserUncheckedCreateInput = {
    id?: number
    user_id: number
    sub_campaign_id: number
    client_id: number
    createdAt?: Date | string
  }

  export type Campaign_UserUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Campaign_UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Campaign_UserCreateManyInput = {
    id?: number
    user_id: number
    sub_campaign_id: number
    client_id: number
    createdAt?: Date | string
  }

  export type Campaign_UserUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Campaign_UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    sub_campaign_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    role?: SortOrder
    password?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    role?: SortOrder
    password?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    title?: SortOrder
    role?: SortOrder
    password?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    industry?: SortOrder
    phone_number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    industry?: SortOrder
    phone_number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    address?: SortOrder
    industry?: SortOrder
    phone_number?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
  }

  export type Sub_CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type Sub_CampaignAvgOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
  }

  export type Sub_CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type Sub_CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    status?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
    createdAt?: SortOrder
  }

  export type Sub_CampaignSumOrderByAggregateInput = {
    id?: SortOrder
    campaign_id?: SortOrder
    owner?: SortOrder
    manager?: SortOrder
    client_id?: SortOrder
    created_by?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    address?: SortOrder
    tag?: SortOrder
    level_priority?: SortOrder
    source?: SortOrder
    status?: SortOrder
    result_negotiation?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    address?: SortOrder
    tag?: SortOrder
    level_priority?: SortOrder
    source?: SortOrder
    status?: SortOrder
    result_negotiation?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    country?: SortOrder
    address?: SortOrder
    tag?: SortOrder
    level_priority?: SortOrder
    source?: SortOrder
    status?: SortOrder
    result_negotiation?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
  }

  export type Contact_ParentCountOrderByAggregateInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ParentAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ParentMinOrderByAggregateInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ParentSumOrderByAggregateInput = {
    id?: SortOrder
    parent_contact_id?: SortOrder
    contact_id?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    tag?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    tag?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    tag?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_NoteCountOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_NoteAvgOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_NoteMinOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_NoteSumOrderByAggregateInput = {
    id?: SortOrder
    sub_campaign_id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_ActivitySumOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
  }

  export type Contact_BantCountOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
    budget?: SortOrder
    authority?: SortOrder
    need?: SortOrder
    time?: SortOrder
    spesification_project?: SortOrder
    next_step?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_BantAvgOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
  }

  export type Contact_BantMaxOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
    budget?: SortOrder
    authority?: SortOrder
    need?: SortOrder
    time?: SortOrder
    spesification_project?: SortOrder
    next_step?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_BantMinOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
    budget?: SortOrder
    authority?: SortOrder
    need?: SortOrder
    time?: SortOrder
    spesification_project?: SortOrder
    next_step?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_BantSumOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    lead_type?: SortOrder
    lead_owner?: SortOrder
  }

  export type Contact_TimelineCountOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_TimelineAvgOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
  }

  export type Contact_TimelineMaxOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_TimelineMinOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Contact_TimelineSumOrderByAggregateInput = {
    id?: SortOrder
    contact_id?: SortOrder
    sub_campaign_id?: SortOrder
  }

  export type Campaign_UserCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Campaign_UserAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
  }

  export type Campaign_UserMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Campaign_UserMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
    createdAt?: SortOrder
  }

  export type Campaign_UserSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    sub_campaign_id?: SortOrder
    client_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}